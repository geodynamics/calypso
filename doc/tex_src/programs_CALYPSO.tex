\section{Preprocessing program ({\tt gen\_sph\_grid})}
\label{section:gen_sph_grid}
%
The following programs are built by compile.
%
\begin{verbatim}
\end{verbatim}
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{images/flow_1}
\end{center}
\caption{Generated files by preprocessing program in Data flow.}
\label{fig:gen_sph_grid}
\end{figure}
%
This program generates index table and a communication table for parallel spherical harmonics, table of integrals for Coriolis term, and FEM mesh information to generate visualization data (see Figure \ref{fig:gen_sph_grid}). This program needs control file for input. This program can perform with {\bf any} number of MPI processes less than the number of subdomains, but is required to run with the SAME number of subdomains to generate MERGED data . The output files include the indexing tables. 

%
\begin{table}[htp]
\caption{List of files for {\tt gen\_sph\_grid} }
\begin{center} 
\begin{tabular}{|c|c|c|c|}
\hline
Files & extension & Parallelization & I/O \\ \hline \hline
Control file & \verb|control_sph_grid| & Single & Input \\ \hline
Index for $(r,j)$ & \verb|[sph_prefix].[rj_extension]|ã€€& - & Output \\
Index for $(r,l,m)$ & \verb|[sph_prefix].[rlm_extension]| & - & Output \\
Index for $(r,t,m)$ & \verb|[sph_prefix].[rtm_extension]| & - & Output \\
Index for $(r,t,p)$ & \verb|[sph_prefix].[rtp_extension]| & - & Output \\ \hline
FEM mesh & \verb|[sph_prefix].[fem_extension]| & - & Output \\ \hline
Radial point list & \verb|radial_info.dat| & Single & Output \\ \hline
\end{tabular}
\end{center}
\label{table:gen_sph_grid}
\end{table}
%
%
\begin{table}[htp]
\caption{data format flag {[\tt sph\_file\_fmt\_ctl]} and extensions.}
\begin{center} 
\begin{tabular}{|c||c|c|c|c|}
\hline
  \multicolumn{5}{|c|}{Distributed files} \\ \hline
  \verb|[sph_file_fmt_ctl]| &  \verb|ascii| & \verb|binary| & \verb|gzip| & \verb|gzip_bin| \\ \hline
\verb|[rj_extension]|  & \verb|[#].rj|  & \verb|[#].brj| & \verb|[#].rj.gz|  & \verb|[#].brj.gz| \\
\verb|[rlm_extension]| & \verb|[#].rlm| & \verb|[#].blm| & \verb|[#].rlm.gz| & \verb|[#].blm.gz| \\
\verb|[rtm_extension]| & \verb|[#].rtm| & \verb|[#].btm| & \verb|[#].rtm.gz| & \verb|[#].btm.gz| \\
\verb|[rtp_extension]| & \verb|[#].rtp| & \verb|[#].btp| & \verb|[#].rtp.gz| & \verb|[#].btp.gz| \\ \hline
\verb|[fem_extension]| & \verb|[#].gfm| & \verb|[#].gfb| & \verb|[#].gfm.gz| & \verb|[#].gfb.gz| \\ \hline \hline
  \multicolumn{5}{|c|}{Single file}  \\ \hline
  \verb|[sph_file_fmt_ctl]| & \verb|merged| & \verb|merged_bin| & \verb|merged_gz| & \verb|merged_bin_gz| \\ \hline
\verb|[rj_extension]|   & \verb|.rj|  & \verb|.brj| & \verb|.rj.gz|  & \verb|.brj.gz| \\
\verb|[rlm_extension]| & \verb|.rlm| & \verb|.blm| & \verb|.rlm.gz| & \verb|.blm.gz| \\
\verb|[rtm_extension]| & \verb|.rtm| & \verb|.btm| & \verb|.rtm.gz| & \verb|.btm.gz| \\
\verb|[rtp_extension]| & \verb|.rtp| & \verb|.btp| & \verb|.rtp.gz| & \verb|.btp.gz| \\ \hline
\verb|[fem_extension]| & \verb|.gfm| & \verb|.gfb| & \verb|.gfm.gz| & \verb|.gfb.gz| \\ \hline \hline
  \multicolumn{5}{c}{{\tt [\#]} is the domain or process number} \\
\end{tabular}
\end{center}
\label{table:mesh_format}
\end{table}
%

My favorite (recommend) data format is \verb|merged_gz|, because we can reduce the number of files in one directory and check the data by using \verb|gunzip -c| command.
%

\subsection{Position of radial grid}
The preprocessing program sets the radial grid spacing, either by a list in the control file or by setting an equidistant grid or Chebyshev collocation points.

In equidistance grid, radial grids are defined by
%
\begin{eqnarray}
r(k) & = & r_{i} + \left(r_{o}-r_{i} \right) \frac{k-k_{ICB}}{N},
\nonumber
\end{eqnarray}
%
where, $k_{ICB}$ is the grid points number at ICB. The radial grid set from the closest points of minimum radius defined by \hyperref[href_i:Min_radius_ctl]{\tt [Min\_radius\_ctl]} in control file to the closest points of the maximum radius defined by \hyperref[href_i:Max_radius_ctl]{\tt [Max\_radius\_ctl]} in control file, and radial grid number for the innermost points is set to $k = 1$.

In Chebyshev collocation points, radial grids in the fluid shell are defined by
%
\begin{eqnarray}
r(k) & = & r_{i} + \frac{\left(r_{o}-r_{i} \right)}{2} \left[ \frac{1}{2} - \cos \left(\pi \frac{ k-k_{ICB}}{N} \right) \right],
\nonumber
\end{eqnarray}
%
For the inner core ($r<r_{i}$), grid points is defined by
%
\begin{eqnarray}
r(k) & = & r_{i} - \frac{\left(r_{o}-r_{i} \right)}{2} \left[ \frac{1}{2} - \cos \left(\pi \frac{ k-k_{ICB}}{N} \right) \right],
\nonumber
\end{eqnarray}
%
and, grid points in the external of the shell ($r>r_{o}$) is defined by
%
\begin{eqnarray}
r(k) & = & r_{o} + \frac{\left(r_{o}-r_{i} \right)}{2} \left[ \frac{1}{2} - \cos \left(\pi \frac{ k-k_{CMB}}{N} \right) \right],
\nonumber
\end{eqnarray}
%
where, $k_{CMB}$ is the grid point number at CMB.

\subsection{Control file (\tt{control\_sph\_shell})}
Control files for Calypso consists of blocks starting and ending with \verb|begin| and \verb|end|, respectively. Entities with more than one components are defined between \verb|begin array| and \verb|end array| flags. The number of components of an array must be defined at \verb|begin array| line. If blocks to be defined in an external file, the external file name is defined by \verb|file| flag. 

\label{section:control_sph_shell}
Control file ({\tt control\_sph\_shell}) consists the following items. Detailed description for each item can be checked by clicking each item.
\\
%
\verb|spherical_shell_ctl|
\label{href_i:spherical_shell_ctl}
\\
\\
%
Block {\tt MHD\_control} (Top block of the control file)
	\begin{itemize}
	\item Block \hyperref[href_t:data_files_def]{\tt data\_files\_def}
%
		\begin{itemize} \label{href_i:data_files_def2}
		\item \hyperref[href_t:num_subdomain_ctl]{\tt num\_subdomain\_ctl    [Num\_PE]}
		\item \hyperref[href_t:sph_file_prefix]{\tt sph\_file\_prefix    [sph\_prefix]}
		\item \hyperref[href_t:sph_file_fmt_ctl]{\tt sph\_file\_fmt\_ctl    [sph\_format]}
		\end{itemize}
%
	\item File \hyperref[href_t:spherical_shell_ctl]{\tt spherical\_shell\_ctl    [resolution\_control]}
	\item or Block \hyperref[href_t:spherical_shell_ctl]{\tt spherical\_shell\_ctl}
%
		\begin{itemize}
		\item (Block \hyperref[href_t:FEM_mesh_ctl]{\tt FEM\_mesh\_ctl})
		\begin{itemize} \label{href_i:FEM_mesh_ctl}
		\item (\hyperref[href_t:FEM_mesh_output_switch]{\tt FEM\_mesh\_output\_switch [ON or OFF]})
		\end{itemize}
%
		\item Block \hyperref[href_t:num_domain_ctl]{\tt num\_domain\_ctl}
			\begin{itemize} \label{href_i:num_domain_ctl}
			\item \hyperref[href_t:num_radial_domain_ctl]{\tt num\_radial\_domain\_ctl [Ndomain]}
			\item \hyperref[href_t:num_horizontal_domain_ctl]{\tt num\_horizontal\_domain\_ctl [Ndomain]}
%
            \item {\color{magenta} Array \hyperref[href_t:num_domain_sph_grid]
				{\tt num\_domain\_sph\_grid    [Direction]    [Ndomain]} \\
				(Depricated)}
			\item {\color{magenta} Array \hyperref[href_t:num_domain_legendre]
				{\tt num\_domain\_legendre    [Direction]    [Ndomain]} \\
				(Depricated)}
			\item {\color{magenta} Array \hyperref[href_t:num_domain_spectr]
				{\tt num\_domain\_spectr      [Direction]    [Ndomain]} \\
				(Depricated)}
			\end{itemize}
%
		\item Block \hyperref[href_t:num_grid_sph]{\tt num\_grid\_sph}
			\begin{itemize} \label{href_i:num_grid_sph}
	        \item \hyperref[href_t:truncation_level_ctl]{\tt truncation\_level\_ctl	[Lmax]}
			\item \hyperref[href_t:ngrid_meridonal_ctl]{\tt ngrid\_meridonal\_ctl [Ntheta]}
			\item \hyperref[href_t:ngrid_zonal_ctl]{\tt ngrid\_zonal\_ctl [Nphi]}
%
			\item \hyperref[href_t:radial_grid_type_ctl]{\tt radial\_grid\_type\_ctl} \\
				\verb|[explicit, Chebyshev, or equi_distance]| \label{href_i:radial_grid_type_ctl}
%
			\item \hyperref[href_t:num_fluid_grid_ctl]{\tt num\_fluid\_grid\_ctl  [Nr\_shell]}
			\item \hyperref[href_t:fluid_core_size_ctl]{\tt fluid\_core\_size\_ctl  [Length]}
			\item \hyperref[href_t:ICB_to_CMB_ratio_ctl]{\tt ICB\_to\_CMB\_ratio\_ctl  [R\_ratio]}
			\item \hyperref[href_t:Min_radius_ctl]{\tt Min\_radius\_ctl  [Rmin]}    
				\label{href_i:Min_radius_ctl}
			\item \hyperref[href_t:Max_radius_ctl]{\tt Max\_radius\_ctl  [Rmax]}    
				\label{href_i:Max_radius_ctl}
%
\\
			\item Array \hyperref[href_t:r_layer]{\tt r\_layer  [Layer \#]  [Radius]}    
%
			\item Array \hyperref[href_t:boundaries_ctl]{\tt boundaries\_ctl  [Boundary\_name]  [Layer \#]}    
			\end{itemize}
		\end{itemize}
	\end{itemize}

If \verb|num_radial_domain_ctl| and \verb|num_horizontal_domain_ctl| are defined, the following arrays \verb|num_domain_sph_grid|, \verb|num_domain_legendre|, and \verb|num_domain_spectr| are not necessary. \\
(see \hyperref[href_t:gen_w_innercore]{example} \verb|spherical_shell/with_inner_core|)

The external file for resoultion and parallelization information \verb|[resolution_control]| needs the following contorl blocks:
%
	\begin{itemize}
	\item Block \hyperref[href_i:spherical_shell_ctl]{\tt spherical\_shell\_ctl}
		\begin{itemize}
		\item Block \hyperref[href_i:FEM_mesh_ctl]{\tt FEM\_mesh\_ctl}
		\item Block \hyperref[href_i:num_domain_ctl]{\tt num\_domain\_ctl}
		\item Block \hyperref[href_i:num_grid_sph]{\tt num\_grid\_sph}
		\end{itemize}
	\end{itemize}
%
\subsection{Spectrum index data}
\verb|gen_sph_grid| generates indexing table of the spherical transform. To perform spherical harmonics transform with distributed memory computers, data communication table is also included in these files. Calypso needs four indexing data for the spherical transform.
%
\begin{description}
\item{\verb|[sph_prefix].[rj_extension]|} Indexing table for spectrum data $f(r,l,m)$ to calculate linear terms. In program,  spherical harmonics modes $(l,m)$ is indexed by $j = l(l+1) + m$. The spectrum data are decomposed by spherical harmonics modes $j$. Data communication table for Legendre transform is included. The data also have the radial index of the ICB and CMB. Extension \verb|[rj_extension]| is listed in Table \ref{table:mesh_format}.
\item{\verb|[sph_prefix].[rlm_extension]|} Indexing table for spectrum data $f(r,l,m)$ for Legendre transform. The spectrum data are decomposed by radial direction $r$ and spherical harmonics order $m$. Data communication table to caricurate liner terms is included. Extension \verb|[rlm_extension]| is listed in Table \ref{table:mesh_format}.
\item{\verb|[sph_prefix].[rtm_extension]|} Indexing table for data $f(r,\theta,m)$ for Legendre transform. The data are decomposed by radial direction $r$ and spherical harmonics order $m$. Data communication table for backward Fourier transform is included. Extension \verb|[rtm_extension]| is listed in Table \ref{table:mesh_format}.
\item{\verb|[sph_prefix].[rtp_extension]|} Indexing table for data $f(r,\theta,m)$ for Fourier transform and field data $f(r,\theta,\phi)$. The data are decomposed by radial direction $r$ and meridional direction $\theta$. Data communication table for forward Legendre transform is included. Extension \verb|[rtp_extension]| is listed in Table \ref{table:mesh_format}.
\end{description}
%

\subsection{Finite element mesh data (optional)}
Calypso generates field data for visualization with XDMF or VTK format. To generate field data file, the preprocessing program generates FEM mesh data for each subdomain of spherical grid $(r,\theta,\phi)$ under the Cartesian coordinate $(x,y,z)$. The mesh data file is written based on GeoFEM (\url{http://geofem.tokyo.rist.or.jp}) mesh data format, which consists of each subdomain mesh and communication table among overlapped nodes. The extension of the mesh file is listed in Table \ref{table:mesh_format}. This mesh data is only used in the programs \hyperref[sec:sectioning]{\tt sectioning} and \verb|field_to_VTK|.

\subsection{Radial grid data}
The preprocessing program generates radius of each layer in \verb|radial_info.dat| if \verb|radial_grid_type_ctl| is set to \verb|Chebyshev| or \verb|equi_distance|. This file consists of blocks \verb|array r_layer| and \verb|array boundaries_ctl| for control file. This data may be useful if you want to modify radial grid spacing by yourself.

\subsection{How to define spatial resolution and parallelization?}
  Calypso uses spherical harmonics expansion method and in horizontal discretization and finite difference methods in the radial direction. In the spherical harmonics expansion methods, nonlinear terms are solved in the grid space while time integration and diffusion terms are solved in the spectrum space. We need to set truncation degree $l_{max}$ of the spherical harmonics and number of grids in the three direction $(N_{r}, N_{\theta}, N_{\phi})$ in the preprocessing program. The following condition is required (or recommended) for $l_{max}$ and $(N_{r}, N_{\theta}, N_{\phi})$. $l_{max}$ is defined by \verb|truncation_level_ctl|, and $N_{r}$ for the fluid shell (outer core) is defined by  \verb|num_fluid_grid_ctl|.  $N_{\theta}$ and $N_{\phi}$ is defined by \verb|ngrid_meridonal_ctl| and \verb|ngrid_zonal_ctl|, respectively.
%
\begin{itemize}
\item $N_{\phi} = 2 N_{\theta}$.
\item $N_{\theta}$ must be more than $l_{max}+1$, but
\item To eliminate aliasing in the spherical transform, $N_{\theta} \ge 1.5 \left( l_{max}+1 \right)$ is highly recommended.
\item $N_{\phi}$ should consists of products among power of 2, power of 3, and power of 5.
\end{itemize}
%
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{images/parallelize}
\end{center}
\caption{Parallelization and data communication in Calypso in the case using 9 (3x3) processors. Data are decomposed in radial and meridional direction for nonlinear term evaluations, decomposed in radial and harmonic order for Legendre transform, and decomposed in spherical harmonics for linear calculations.}
\label{fig:parallelization}
\end{figure}
%
Calypso is parallelized 2-dimensionally and direction of the parallelization is changed in the operations in the spherical transform (See Figure \ref{fig:parallelization}). Two dimensional parallelization delivers many parallelize configuration. Here is the approach  how to find the best configuration:
%
\begin{itemize}
\item Maximum parallelization level in horizontal direction is $\left( l_{max} + 1 \right)  /2$,  and $N_{r}+1$ is the maximum level in radial direction.
\item Decompose number of radial points $N_{r}+1$ and truncation degree $\left( l_{max} + 1 \right) / 2 $ into prime numbers.
\item Decide number of MPI processes from the prime numbers.
\item Choose the number of decomposition in the radial and horizontal direction as close as possible.
\end{itemize}
% 
Here is an example for the case with $(N_{r}, l_{max}) = (89, 95)$. The maximum number of parallelization is $90 \times 48  = 4320$ processes.  $N_{r}+1$ and $\left( l_{max} + 1 \right)  /2$ can be decomposed into $90 = 2 \times 3^2 \times 5$ and $48 = 2^4 \times 3 $. Now, if 160 processes run is intended, $160 = 10 \times 16$ is the closest number of decompositions. Comparing with the prime numbers of the spatial resolution, radial and horizontal decomposition will be 10 and 16, respectively.

\newpage
\section{Simulation program ({\tt sph\_mhd})}
\label{section:sph_mhd}
%

The name of the simulation program is {\tt sph\_mhd}. This program requires {\tt control\_MHD} as a Control file. This program performs with the indexing file for spherical harmonics and Coriolis term integration file generated by the preprocessing program {\tt gen\_sph\_grid}.
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{images/flow_2}
\end{center}
\caption{Data flow for the simulation program.}
\label{fig:flow_2}
\end{figure}
%
Data files for this program are listed in Table \ref{table:sph_mhd}. Indexing data for spherical harmonics which starting with \verb|[sph_prefix]| are obtained by the preprocessing program \verb|gen_sph_grid|. If these indexing data files do not exist, the spherical harmonics indexing data files are also generated by using information in \verb|spherical_shell_ctl| block. The boundary condition data file \verb|[boundary_data_name]| is optionally required if boundary conditions for temperature and composition are not homogenous.
%
\begin{table}[htp]
\caption{List of files for simulation {\tt sph\_mhd} }
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
 name & Parallelization & I/O \\ \hline \hline
\verb|control_MHD| & Serial & Input \\ \hline
\verb|[sph_prefix].[rj_extension]|  & - & Input / (Output) \\
\verb|[sph_prefix].[rlm_extension]| & - & Input / (Output) \\
\verb|[sph_prefix].[rtm_extension]| & - & Input / (Output) \\
\verb|[sph_prefix].[rtp_extension]| & - & Input / (Output) \\ \hline
\verb|[sph_prefix].[fem_extension]| & - & (Input / Output) \\ \hline
\verb|[boundary_data_name]| & Single & Input \\ \hline
\verb|[rst_prefix].[step #].[rst_extension]| &  - & Input/Output  \\ \hline
\verb|[vol_pwr_prefix]_s.dat| & Single & Output \\ \hline
\verb|[vol_pwr_prefix]_l.dat| & Single & Output \\
\verb|[vol_pwr_prefix]_m.dat| & Single & Output \\
\verb|[vol_pwr_prefix]_lm.dat| & Single & Output \\
\verb|[vol_ave_prefix].dat| & Single & Output \\ \hline
\verb|[layer_pwr_prefix]_s.dat| & Single & Output \\
\verb|[layer_pwr_prefix]_l.dat| & Single & Output \\
\verb|[layer_pwr_prefix]_m.dat| & Single & Output \\
\verb|[layer_pwr_prefix]_lm.dat| & Single & Output \\ \hline
\verb|[gauss_coef_prefix].dat| & Single & Output   \\
\verb|[picked_sph_prefix].dat| & Single & Output   \\ \hline
\verb|[nusselt_number_prefix].dat| & Single & Output   \\ \hline
\verb|[fld_prefix].[step#].[domain#].[extension]| &  - & Output  \\ \hline
\verb|[section_prefix].[step#].[extension]| &  Single & Output  \\
\verb|[isosurface_prefix].[step#].[extension]| &  Single & Output  \\ \hline
\end{tabular}
\end{center}
(Output): Marked files are generated if files do not exist.
\label{table:sph_mhd}
\end{table}
%
%
\begin{table}[htp]
\caption{data format flag {[\tt restart\_file\_fmt\_ctl]} and extensions for the restart file.}
\begin{center} 
\begin{tabular}{|c||c|c|c|c|}
\hline
  \multicolumn{5}{|c|}{Distributed files} \\ \hline
  \verb|[sph_file_fmt_ctl]| &  \verb|ascii| & \verb|binary| & \verb|gzip| & \verb|gzip_bin| \\ \hline
\verb|[rst_extension]| & \verb|[#].fst| & \verb|[#].fsb| & \verb|[#].fst.gz| & \verb|[#].fsb.gz| \\ \hline \hline
  \multicolumn{5}{|c|}{Single file}  \\ \hline
  \verb|[sph_file_fmt_ctl]| & \verb|merged| & \verb|merged_bin| & \verb|merged_gz| & \verb|merged_bin_gz| \\ \hline
\verb|[rst_extension]| & \verb|.fst| & \verb|.fsb| & \verb|.fst.gz| & \verb|.fsb.gz| \\ \hline \hline
  \multicolumn{5}{c}{{\tt [\#]} is the domain or process number} \\
\end{tabular}
\end{center}
\label{table:restart_format}
\end{table}
%
%
\newpage
\subsection{Control file}
The format of the control file \verb|control_MHD| is described below. The detail of each block is described in section \ref{section:def_control}. You can jump to detailed description by clicking each item. \\
\\
%
Block \verb|MHD_control|  (Top block of the control file)
\label{href_i:MHD_control}
%
\begin{itemize}
\item Block \hyperref[href_t:data_files_def]{\tt data\_files\_def}
	\label{href_i:data_files_def}
%
	\begin{itemize}
	\item \hyperref[href_t:num_subdomain_ctl]
			{\tt num\_subdomain\_ctl    [Num\_PE]}
	\item \hyperref[href_t:num_smp_ctl]
			{\tt num\_smp\_ctl    [Num\_Threads]}
	\item \hyperref[href_t:sph_file_prefix]
			{\tt sph\_file\_prefix    [sph\_prefix]}
	\item \hyperref[href_t:boundary_data_file_name]
		{\tt boundary\_data\_file\_name    [boundary\_data\_name]}
%
	\item \hyperref[href_t:restart_file_prefix]
		{\tt restart\_file\_prefix    [rst\_prefix])}
	\item \hyperref[href_t:field_file_prefix]
			{\tt field\_file\_prefix    [fld\_prefix]}
%
	\item \hyperref[href_t:sph_file_fmt_ctl]
			{\tt sph\_file\_fmt\_ctl    [sph\_format]}
	\item \hyperref[href_t:restart_file_fmt_ctl]
			{\tt restart\_file\_fmt\_ctl    [rst\_format]}
	\item \hyperref[href_t:field_file_fmt_ctl]
			{\tt field\_file\_fmt\_ctl    [fld\_format]}
	\end{itemize}
%
\item (File or Block \hyperref[href_i:spherical_shell_ctl]
			{\tt spherical\_shell\_ctl        [resolution\_control]})
	\begin{itemize}
	\item (Block \hyperref[href_i:FEM_mesh_ctl]
        {\tt FEM\_mesh\_ctl} See Section \ref{section:gen_sph_grid})
	\item (Block \hyperref[href_i:num_domain_ctl]
		{\tt num\_domain\_ctl} See Section \ref{section:gen_sph_grid})
	\item (Block \hyperref[href_i:num_grid_sph]
		{\tt num\_grid\_sph} See Section \ref{section:gen_sph_grid})
	\end{itemize}
%
\item Block \verb|model|
	\begin{itemize}
	\item Block \hyperref[href_t:phys_values_ctl]{\tt phys\_values\_ctl}
		\begin{itemize} \label{href_i:phys_values_ctl}
		\item Array \hyperref[href_t:nod_value_ctl]
			{\tt nod\_value\_ctl    [Field]  [Viz\_flag]  [Monitor\_flag]}
		\end{itemize}
%
	\item Block \hyperref[href_t:time_evolution_ctl]{\tt time\_evolution\_ctl}
		\begin{itemize} \label{href_i:time_evolution_ctl}
		\item Array \hyperref[href_t:time_evo_ctl]
			{\tt time\_evo\_ctl    [Field]}
		\end{itemize}
%
	\item Block \hyperref[href_t:boundary_condition]{\tt boundary\_condition}
		\begin{itemize} \label{href_i:boundary_condition}
		\item Array \hyperref[href_t:bc_temperature]
            {\tt bc\_temperature       [Group]  [Type]  [Value]}
		\item Array \hyperref[href_t:bc_velocity]
			{\tt bc\_velocity          [Group]  [Type]  [Value]}
		\item Array \hyperref[href_t:bc_composition]
			{\tt bc\_composition       [Group]  [Type]  [Value]}
		\item Array \hyperref[href_t:bc_magnetic_field]
			{\tt bc\_magnetic\_field    [Group]  [Type]  [Value]}
		\end{itemize}
%
	\item Block \hyperref[href_t:forces_define]{\tt forces\_define}
		\begin{itemize} \label{href_i:forces_define}
		\item Array \hyperref[href_t:force_ctl]{\tt force\_ctl    [Force]}
		\end{itemize}
%
	\item Block \hyperref[href_t:dimensionless_ctl]{\tt dimensionless\_ctl}
		\begin{itemize} \label{href_i:dimensionless_ctl}
		\item Array \hyperref[href_t:dimless_ctl]{\tt dimless\_ctl    [Name]  [Value]}
		\end{itemize}
%
	\item Block \hyperref[href_t:coefficients_ctl]{\tt coefficients\_ctl}
		\begin{itemize} \label{href_i:coefficients_ctl}
		\item Block \hyperref[href_t:thermal]{\tt thermal}
			\begin{itemize} \label{href_i:thermal}
			\item Array \hyperref[href_t:coef_4_termal_ctl]
					{\tt coef\_4\_termal\_ctl          [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_t_diffuse_ctl]
					{\tt coef\_4\_t\_diffuse\_ctl      [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_heat_source_ctl]
					{\tt coef\_4\_heat\_source\_ctl    [Name] [Power]}
			\end{itemize}
%
		\item Block \hyperref[href_t:momentum]{\tt momentum}
			\begin{itemize} \label{href_i:momentum}
			\item Array \hyperref[href_t:coef_4_velocity_ctl]
				{\tt coef\_4\_velocity\_ctl          [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_press_ctl]
				{\tt coef\_4\_press\_ctl             [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_v_diffuse_ctl]
                {\tt coef\_4\_v\_diffuse\_ctl         [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_buoyancy_ctl]
				{\tt coef\_4\_buoyancy\_ctl          [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_Coriolis_ctl]
				{\tt coef\_4\_Coriolis\_ctl          [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_Lorentz_ctl]
				{\tt coef\_4\_Lorentz\_ctl           [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_composit_buoyancy_ctl]
				{\tt coef\_4\_composit\_buoyancy\_ctl [Name] [Power]}
			\end{itemize}
%
		\item Block \hyperref[href_t:induction]{\tt induction}
			\begin{itemize} \label{href_i:induction}
			\item Array \hyperref[href_t:coef_4_magnetic_ctl]
				{\tt coef\_4\_magnetic\_ctl   [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_m_diffuse_ctl]
				{\tt coef\_4\_m\_diffuse\_ctl [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_induction_ctl]
				{\tt coef\_4\_induction\_ctl  [Name] [Power]}
			\end{itemize}
%
		\item Block \hyperref[href_t:composition]{\tt composition}
			\begin{itemize} \label{href_i:composition}
			\item Array \hyperref[href_t:coef_4_composition_ctl]
				{\tt coef\_4\_composition\_ctl         [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_c_diffuse_ctl]
				{\tt coef\_4\_c\_diffuse\_ctl          [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_composition_source_ctl]
				{\tt coef\_4\_composition\_source\_ctl [Name] [Power]}
			\end{itemize}
		\end{itemize}
%
%	\item Block \hyperref[href_t:gravity_define]{\tt gravity\_define}
%		\begin{itemize} \label{href_i:gravity_define}
%		\item \verb||
%				\hyperref[href_t:gravity_type_ctl]{\tt gravity\_type\_ctl    [Name]}
%		\end{itemize}
%
%	\item Block \hyperref[href_t:Coriolis_define]{\tt Coriolis_define}
%		\begin{itemize} \label{href_i:Coriolis_define}
%		\item Array \hyperref[href_t:rotation_vec]
%				{\tt rotation\_vec    [Direction] [Value]}
%		\end{itemize}
%
	\item Block \hyperref[href_t:temperature_define]{\tt temperature\_define}
		\begin{itemize} \label{href_i:temperature_define}
		\item \verb||
				\hyperref[href_t:ref_temp_ctl]{\tt ref\_temp\_ctl        [REFERENCE\_TEMP]}
		\item Block \hyperref[href_t:low_temp_ctl]{\tt low\_temp\_ctl}
			\begin{itemize}
			\item \hyperref[href_t:depth]      {\tt depth        [RADIUS]}
			\item \hyperref[href_t:temperature]{\tt temperature  [TEMPERATURE]}
			\end{itemize}
%
		\item Block \hyperref[href_t:high_temp_ctl]{\tt high\_temp\_ctl}
			\begin{itemize}
			\item \hyperref[href_t:depth]      {\tt depth        [RADIUS]}
			\item \hyperref[href_t:temperature]{\tt temperature  [TEMPERATURE]}
			\end{itemize}
		\end{itemize}
	\end{itemize}
%
\item Block \verb|control|
	\begin{itemize}
	\item Block \hyperref[href_t:time_step_ctl]{\tt time\_step\_ctl}
		\begin{itemize} \label{href_i:time_step_ctl}
		\item \hyperref[href_t:elapsed_time_ctl]
			{\tt elapsed\_time\_ctl        [ELAPSED\_TIME]}
		\item \hyperref[href_t:i_step_init_ctl]
			{\tt i\_step\_init\_ctl        [ISTEP\_START]}
		\item \hyperref[href_t:i_step_finish_ctl]
			{\tt i\_step\_finish\_ctl      [ISTEP\_FINISH]}
		\item \hyperref[href_t:i_step_check_ctl]
			{\tt i\_step\_check\_ctl       [ISTEP\_MONITOR]}
		\item \hyperref[href_t:i_step_rst_ctl]
			{\tt i\_step\_rst\_ctl         [ISTEP\_RESTART]}
		\item \hyperref[href_t:i_step_field_ctl]
			{\tt i\_step\_field\_ctl       [ISTEP\_FIELD]}
		\item \hyperref[href_t:i_step_sectioning_ctl]
			{\tt i\_step\_sectioning\_ctl  [ISTEP\_SECTION]}
		\item \hyperref[href_t:i_step_isosurface_ctl]
			{\tt i\_step\_isosurface\_ctl  [ISTEP\_ISOSURFACE]}
		\item \hyperref[href_t:dt_ctl]
			{\tt dt\_ctl                   [DELTA\_TIME]}
		\item \hyperref[href_t:time_init_ctl]
			{\tt time\_init\_ctl           [INITIAL\_TIME]}
		\end{itemize}
%
	\item Block \hyperref[href_t:restart_file_ctl]{\tt restart\_file\_ctl}
		\begin{itemize} \label{href_i:restart_file_ctl}
		\item \hyperref[href_t:rst_ctl]{\tt rst\_ctl      [INITIAL\_TYPE]}
		\end{itemize}
%
	\item Block \verb||
    		\hyperref[href_t:time_loop_ctl]{\tt time\_loop\_ctl}
		\begin{itemize} \label{href_i:time_loop_ctl}
		\item \hyperref[href_t:scheme_ctl]{\tt scheme\_ctl              [EVOLUTION\_SCHEME]}
		\item \hyperref[href_t:coef_imp_v_ctl]{\tt coef\_imp\_v\_ctl    [COEF\_INP\_U]}
		\item \hyperref[href_t:coef_imp_t_ctl]{\tt coef\_imp\_t\_ctl    [COEF\_INP\_T]}
		\item \hyperref[href_t:coef_imp_b_ctl]{\tt coef\_imp\_b\_ctl    [COEF\_INP\_B]}
		\item \hyperref[href_t:coef_imp_c_ctl]{\tt coef\_imp\_c\_ctl    [COEF\_INP\_C]}
		\item \hyperref[href_t:FFT_library_ctl]{\tt FFT\_library\_ctl   [FFT\_Name]}
		\item \hyperref[href_t:Legendre_trans_loop_ctl]
			{\tt Legendre\_trans\_loop\_ctl [Leg\_Loop]}
		\end{itemize}
%
	\end{itemize}
%
\item Block \hyperref[href_t:sph_monitor_ctl]{\tt sph\_monitor\_ctl}
	\begin{itemize} \label{href_i:sph_monitor_ctl}
	\item \hyperref[href_t:volume_average_prefix]
			{\tt volume\_average\_prefix        [vol\_ave\_prefix]}
	\item \hyperref[href_t:volume_pwr_spectr_prefix]
			{\tt volume\_pwr\_spectr\_prefix    [vol\_pwr\_prefix]}
	\item \hyperref[href_t:nusselt_number_prefix]
			{\tt nusselt\_number\_prefix        [nusselt\_number\_prefix]}
%
	\item Array \hyperref[href_t:volume_spectrum_ctl]{\tt volume\_spectrum\_ctl}
		\begin{itemize}
		\item Block \verb|volume_spectrum_ctl|
			\begin{itemize}
			\item \hyperref[href_t:volume_average_prefix]
				{\tt volume\_average\_prefix      [vol\_ave\_prefix]}
			\item \hyperref[href_t:volume_pwr_spectr_prefix]
				{\tt volume\_pwr\_spectr\_prefix  [vol\_pwr\_prefix]}
			\item \hyperref[href_t:inner_radius_ctl]
				{\tt inner\_radius\_ctl           [radius]}
			\item \hyperref[href_t:outer_radius_ctl]
				{\tt outer\_radius\_ctl           [radius]}
			\end{itemize}
		\end{itemize}
%
	\item Block \hyperref[href_t:layered_spectrum_ctl]{\tt layered\_spectrum\_ctl}
		\begin{itemize}
		\item \hyperref[href_t:layered_pwr_spectr_prefix]
				{\tt layered\_pwr\_spectr\_prefix         [layer\_pwr\_prefix]}
			\item Array \hyperref[href_t:spectr_layer_ctl]
				{\tt spectr\_layer\_ctl [Layer \#] }
		\end{itemize}
%
	\item Block \hyperref[href_t:gauss_coefficient_ctl]{\tt gauss\_coefficient\_ctl}
		\begin{itemize}
		\item \hyperref[href_t:gauss_coefs_prefix]
			{\tt gauss\_coefs\_prefix                [gauss\_coef\_prefix]}
		\item \hyperref[href_t:gauss_coefs_radius_ctl]
            {\tt gauss\_coefs\_radius\_ctl           [gauss\_coef\_radius]}
			\item Array \hyperref[href_t:pick_gauss_coefs_ctl]
                		{\tt pick\_gauss\_coefs\_ctl  [Degree]   [Order]}
		\item Array \hyperref[href_t:pick_gauss_coef_degree_ctl]
                    {\tt pick\_gauss\_coef\_degree\_ctl  [Degree]}
		\item Array \hyperref[href_t:pick_gauss_coef_order_ctl]
					{\tt pick\_gauss\_coef\_order\_ctl   [Order]}
		\end{itemize}
%
	\item Block \hyperref[href_t:pickup_spectr_ctl]{\tt pickup\_spectr\_ctl}
		\begin{itemize}
		\item \hyperref[href_t:picked_sph_prefix]
			{\tt picked\_sph\_prefix                    [picked\_sph\_prefix]|}
		\item Array \hyperref[href_t:pick_layer_ctl]
					{\tt pick\_layer\_ctl               [Layer \#]}
		\item Array \hyperref[href_t:pick_sph_spectr_ctl]
					{\tt pick\_sph\_spectr\_ctl         [Degree]  [Order]}
		\item Array \hyperref[href_t:pick_sph_degree_ctl]
					{\tt pick\_sph\_degree\_ctl         [Degree]}
		\item Array \hyperref[href_t:pick_sph_order_ctl]
					{\tt pick\_sph\_order\_ctl          [Order]}
		\end{itemize}
%
	\item Block \hyperref[href_t:mid_equator_monitor_ctl]
				{\tt mid\_equator\_monitor\_ctl}
		\begin{itemize}
		\item \hyperref[href_t:nphi_mid_eq_ctl]
				{\tt nphi\_mid\_eq\_ctl   [Nphi\_mid\_equator]}
				\label{href_i:nphi_mid_eq_ctl}
		\end{itemize}
	\end{itemize}
%
\item Block \hyperref[href_t:visual_control]{\tt visual\_control}
    \begin{itemize} \label{href_i:visual_control}
	\item \hyperref[href_t:i_step_sectioning_ctl]
        {\tt i\_step\_sectioning\_ctl  [ISTEP\_SECTION]}
    \item Array \hyperref[href_t:cross_section_ctl]{\tt cross\_section\_ctl}
		\begin{itemize}
        \item File or Block {\tt cross\_section\_ctl} \\
                            {\tt [section\_control\_file]} \\
								(See section \ref{section:section_control})
		\end{itemize}
%
    \item \hyperref[href_t:i_step_isosurface_ctl]
		{\tt i\_step\_isosurface\_ctl  [ISTEP\_ISOSURFACE]}
    \item Array \hyperref[href_t:isosurface_ctl]{\tt isosurface\_ctl}
		\begin{itemize}
		\item File or Block {\tt isosurface\_ctl} \\
                            {\tt [isosurface\_control\_file]} \\
								(See section \ref{section:isosurface_control})
		\end{itemize}
    \end{itemize}
%
\item Block \hyperref[href_t:dynamo_vizs_control]{\tt dynamo\_vizs\_control}
	\begin{itemize} \label{href_i:dynamo_vizs_control}
		\item File or Block \hyperref[href_t:zonal_mean_section_ctl]
							{\tt zonal\_mean\_section\_ctl} \\
							{\tt [zonal\_mean\_section\_control\_file]} \\
								(See section \ref{section:section_control})
		\item File or Block \hyperref[href_t:zonal_RMS_section_ctl]
							{\tt zonal\_RMS\_section\_ctl} \\
                            {\tt [zonal\_RMS\_section\_control\_file]} \\
                                (See section \ref{section:section_control})
%
		\item Block \hyperref[href_t:crustal_filtering_ctl]{\tt crustal\_filtering\_ctl}
			\begin{itemize}
				\item \hyperref[href_t:crustal_filtering_ctl]
						{\tt truncation\_degree\_ctl          [Degree]}
			\end{itemize}
	\end{itemize}
\end{itemize}
%
\verb|spherical_shell_ctl| block is required if spherical harmonics indexing files are not exist.
%
\subsection{Spectrum data for restarting}
Spectrum data is used for restarting data and generating field data by Data transform program \verb|sph_snapshot|, \verb|sph_zm_snapshot|, or \verb|sph_dynamobench|. This file is saved for each subdomain (MPI processes), then \verb|[step #]| and \verb|[domain #]| are added in the file name. The \verb|[step #]| is calculated by \verb|time step| / \verb|[ISTEP_RESTART]|. Data format is defined by \verb|[restart_file_fmt_ctl]| as shown in Table \ref{table:restart_format}.

\subsection{Thermal and compositional boundary condition data file}\label{sec:boundary_file}
Thermal and compositional heterogeneity at boundaries are defined by a external file named  \verb|[boundary_data_name]|. In this file, temperature, composition, heat flux, or compositional flux at ICB or CMB can be defined by spherical harmonics coefficients. To use boundary conditions in \verb|[boundary_data_name]|, file name is defined by \verb|boundary_data_file_name| column in control file, and boundary condition type \verb|[type]| is set to \verb|fixed_file| or \verb|fixed_flux_file| in \verb|bc_temperature| or \verb|bc_composition| column. By setting \verb|fixed_file| or \verb|fixed_flux_file| in control file, boundary conditions are copied from the file \verb|[boundary_data_name]|.

An example of the boundary condition file is shown in Figure \ref{fig:boundary_file}. As for the control file, a line starting from '\verb|#|' or '\verb|!|' is recognized as a comment line. In \verb|[boundary_data_name]|, boundary condition data is defined as following:
%
\begin{enumerate}
\item  Number of total boundary conditions to be defined in this file.
\item  Field name to define the first boundary condition
\item  Place to define the first boundary condition (\verb|ICB| or \verb|CMB|)
\item  Number of spherical harmonics modes for each boundary condition
\item  Spectrum data for the boundary conditions (degree $l$, order $m$, and harmonics coefficients)
\item  After finishing the list of spectrum data return to Step 2 for the next boundary condition
\end{enumerate}
%
If harmonics coefficients of the boundary conditions are not listed in item 5, 0.0 is automatically applied for the harmonics coefficients of the boundary conditions. So, only non-zero components need to be listed in the boundary condition file.

%
\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
#
#  number of boundary conditions
      4
#
#   boundary condition data list
#
#    Fixed temperature at ICB
temperature
ICB
    3
  0  0   1.0E+00
  1  1   2.0E-01
  2  2   3.0E-01
#
#    Fixed heat flux at CMB
heat_flux
CMB
   2
  0  0    -0.9E+0
  1  -1    5.0E-1
#
#    Fixed composition flux at ICB
composite_flux
ICB
   2
  0  0    0.0E+00
  2  0   -2.5E-01
#
#    Fixed composition at CMB
composition
CMB
   2
  0   0   1.0E+00
  2  -2   5.0E-01
\end{verbatim}
\end{center}
\caption{An example of boundary condition file.}
\label{fig:boundary_file}
\end{figure}
%

\subsection{Field data for visualization}
\label{sec:VTK}
Field data is used for the visualization processes. Field data are written with XDMF format (\url{http://www.xdmf.org/index.php/Main_Page}), merged VTK, or distributed VTK format (\url{http://www.vtk.org/VTK/img/file-formats.pdf}). The output data format is defined by \verb|fld_format|. Visualization applications which we checked are listed in Table \ref{table:Viz_app}. Because the field data is written by using Cartesian coordinate $(x,y,z)$ system, coordinate conversion is required to plot vector field in spherical coordinate $(r, \theta, \phi)$ or cylindrical coordinate $(s,\phi, z)$. We will introduce a example of visualization process using ParaView in Section \ref{sec:paraview}. Field data also output merged ASCII or binary format including compression using zlib. These original formats have smaller file size than VTK format because of excluding grid information. Program \hyperref[sec:field_to_VTK]{\tt field\_to\_VTK} generates VTK file from FEM mesh data and field data.
%
\begin{table}[htp]
\caption{Checked visualization application}
\label{table:Viz_app}
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
Control flag & \verb|fld_format| & Application \\ \hline \hline
\verb|VTK| & Distributed VTK & ParaView \\ \hline
\verb|single_VTK| & Merged VTK & ParaView, VisIt, or Mayavi \\ \hline
\verb|VTK_gzip| & Compressed Distributed VTK & ParaView \\
 & & after expanding by {\tt gzip} \\ \hline
\verb|single_VTK_gz| & Compressed Merged VTK & ParaView, VisIt or Mayavi \\
 & &  after expanding by {\tt gzip} \\ \hline
\verb|single_HDF5| & XDMF   & ParaView, VisIt   \\ \hline
\verb|ascii| & Distributed ASCII & - \\
\verb|binary| & Distributed binary & - \\
\verb|gzip| & Distributed compressed ASCII & - \\
\verb|bin_gz| & Distributed compressed binary & - \\
\verb|merged| & Merged ASCII & - \\
\verb|merged_bin| & Merged binary & - \\
\verb|merged_gzip| & Merged compressed ASCII & - \\
\verb|merged_bin_gz| & Merged compressed binary & - \\ \hline

\end{tabular}
\end{center}
More informations about ParaView is in \url{https://www.paraview.org}. \\
More informations about VisIt is in \url{https://wci.llnl.gov/codes/visit/}. \\
More informations about Mayavi is in \url{http://mayavi.sourceforge.net/}. \\
\end{table}
%

\subsubsection{Distributed VTK data}
Distributed VTK data have the following advantage and disadvantages to use:
%
\begin{itemize}
\item Advantage
\begin{itemize} 
\item Faster output
\item No external library is required
\end{itemize}
\item Disadvantage
\begin{itemize} 
\item Many data files are generated
\item Total data file size is large
\item Only ParaView supports this format
\end{itemize}
\end{itemize}
%
Distributed VTK data consist files listed in Table \ref{table:parallel_vtk}. For ParaView, all subdomain data is read by choosing \verb|[fld_prefix].[step#].pvtk| in file menu.
%
\begin{table}[htp]
\caption{List of written files for distributed VTK format}
\begin{center} 
\begin{tabular}{|c|c|}
\hline
 name &  \\ \hline \hline
\verb|[fld_prefix].[step#].[domain#].vtk|  & VTK data for each subdomain  \\ \hline
\verb|[fld_prefix].[step#].pvtk| & Subdomain file list for Paraview  \\ \hline
\end{tabular}
\end{center}
\label{table:parallel_vtk}
\end{table}
%

\subsubsection{Merged VTK data}
Merged VTK data have the following advantage and disadvantages to use:
%
\begin{itemize}
\item Advantage
\begin{itemize} 
\item Merged field data is generated
\item No external library is required
\item Many applications support VTK format
\end{itemize}
\item Disadvantage
\begin{itemize} 
\item Very slow to output
\item Total data file size is large
\end{itemize}
\end{itemize}
%
Merged VTK data generate files listed in Table \ref{table:Merged_vtk}. 
%
\begin{table}[htp]
\caption{List of written files for merged VTK format}
\begin{center} 
\begin{tabular}{|c|c|}
\hline
 name &  \\ \hline \hline
\verb|[fld_prefix].[step#].vtk|  & Merged VTK data  \\ \hline
\end{tabular}
\end{center}
\label{table:Merged_vtk}
\end{table}
%

\subsubsection{Merged XDMF data}
Merged XDMF data have the following advantage and disadvantages to use:
%
\begin{itemize}
\item Advantage
\begin{itemize} 
\item Fastest output
\item Merged field data is generated
\item File size is smaller than the VTK formats
\end{itemize}
\item Disadvantage
\begin{itemize} 
\item Parallel HDF5 library should be required to use
\end{itemize}
\end{itemize}
%
Merged XDMF data generate files listed in Table \ref{table:XDMF}. For ParaView, all subdomain data is read by choosing \verb|[fld_prefix].solution.xdmf| in file menu.
%
\begin{table}[htp]
\caption{List of written files for XDMF format}
\begin{center} 
\begin{tabular}{|c|c|}
\hline
 name &  \\ \hline \hline
\verb|[fld_prefix].mesh.h5|  & HDF5 file for geometry data \\ \hline
\verb|[fld_prefix].[step#].h5|  &HDF5 file for field data   \\ \hline
\verb|[fld_prefix].solution.xdmf|  & HDF5 file lists to be read  \\ \hline
\end{tabular}
\end{center}
\label{table:XDMF}
\end{table}
%
\subsubsection{Calypso field data}
Calypso field data is based on the spectr data for restarting. The data is simply replaced from spherical harmonics coefficients to each component of field data in the cartesian coordinate. The file format flag \verb|[field_file_fmt_ctl]| and corresponding extensiton are showw in Table \ref{table:field_format}.
%
\begin{table}[htp]
\caption{Data format flag {[\tt field\_file\_fmt\_ctl]} and extensions for the field file.}
\begin{center} 
\begin{tabular}{|c||c|c|c|c|}
\hline
\multicolumn{5}{|c|}{Distributed files} \\ \hline
\verb|[field_file_fmt_ctl]| &  \verb|ascii| & \verb|binary| & \verb|gzip| & \verb|gzip_bin| \\ \hline
\verb|[extension]| & \verb|[#].fld| & \verb|[#].flb| & \verb|[#].fld| & \verb|[#].flb.gz| \\ \hline \hline
\multicolumn{5}{|c|}{Single file}  \\ \hline
\verb|[field_file_fmt_ctl]| & \verb|merged| & \verb|merged_bin| & \verb|merged_gz| & \verb|merged_bin_gz| \\ \hline
\verb|[extension]| & \verb|.fld| & \verb|.flb| & \verb|.fld| & \verb|.flb.gz| \\ \hline \hline
\multicolumn{5}{c}{{\tt [\#]} is the domain or process number} \\
\end{tabular}
\end{center}
\label{table:field_format}
\end{table}
%

%
\subsection{Cross section data (Parallel Surfacing module)}
\label{section:PSF}
Calypso can output cross section data for visualization with finer time increment than the whole domain data. The cross section data consist of triangle patches with VTK format, then data can be visualized by Paraview like as the whole field data. This cross sectioning module can output arbitrary quadrature surface, but plane, sphere, and cylindrical section would be useful for the geodynamo simulations.

To output cross sectioning, increment of the surface output data should be defined by \verb|i_step_sectioning_ctl| in \verb|time_step_ctl| block. And, array block \\ \verb|cross_section_ctl| in \verb|visual_control| section is required to define cross sections. Each \verb|cross_section_ctl| block defines one cross section. Each cross section can also define by an external file by specifying external file name with \verb|file| label.
%
The sections shown in Table \ref{table:section_list} are supported in the sectioning module. These surfaces are defined in the Cartesian coordinate.
\begin{table}[htp]
\caption{Supported cross sections}
\begin{center}
\begin{tabular}{|c|c|}
\hline
Surface type & equation \\ \hline
Quadrature surface 
 & $a x^2 + b y^2 + c z^2 + d y z + e z x + f x y + g x + h y + j z + k = 0$ \\
Plane surface 
& $a \left(x-x_{0} \right) + b \left(y-y_{0} \right) + c \left(z-z_{0} \right) = 0$ \\
 Sphere 
& $\left(x-x_{0} \right)^2 + \left(y-y_{0} \right)^2 + \left(z-z_{0} \right)^2 = r^2$  \\
 Ellipsoid 
& $\displaystyle{ \left(\frac{x-x_{0}}{a} \right)^2 + \left( \frac{y-y_{0}}{b} \right)^2 + \left( \frac{z-z_{0}}{c} \right)^2} = 1$ \\
\hline
\end{tabular}
\end{center}
\label{table:section_list}
\end{table}
%
The easiest approarch is using sections defined by quadrature function with ten coefficients from $a$ to $k$ in the control array \verb|coefs_ctl|.

A plane surface is defined by a normal vector $(a, b, c)$ and one point including the surface $(x_{0}, y_{0}, z_{0})$ in arrays \verb|normal_vector| and \verb|center_position|, respectively.

A sphere surface is defined by the position of the center $(x_{0}, y_{0}, z_{0})$ and radius $r$ in array \verb|center_position| and \verb|radius|, respectively.

An Ellipsoid surface is defined the position of the center $(x_{0}, y_{0}, z_{0})$ and length of the each axis $(a, b, c)$ in arrays  \verb|center_position| and \verb|axial_length|, respectively. If one component of the \verb|axial_length| is set to 0, surfacing module generate a Ellipsoidal tube along with the axis where \verb|axial_length| is set to 0.

Area for visualization can be defined by array \verb|chosen_ele_grp_ctl| by choosing \verb|outer_core|, \verb|inner_core|, and \verb|all|. Fields to display is defined in array \verb|output_field|. In array \verb|output_field|, field type in Table \ref{table:field_type} needs to defined. The same field can be defined more than once in array \verb|output_field| to output vector field in Cartesian coordinate and radial component, for example.
%
\begin{table}[htp]
\caption{List of field type for cross sectioning and isosurface module}
\label{table:field_type}
\begin{center} 
\begin{tabular}{|c|c|}
\hline
 Definition & Field type  \\ \hline \hline
 \verb|scalar| & scalar field  \\ \hline
 \verb|vector| & Cartesian vector field \\ \hline
 \verb|x| & $x$-component  \\ \hline
 \verb|y| & $y$-component  \\ \hline
 \verb|z| & $z$-component  \\ \hline
 \verb|radial| & radial ($r$-) component  \\ \hline
 \verb|theta| & $\theta$-component  \\ \hline
 \verb|phi| & $\phi$-component  \\ \hline
 \verb|cylinder_r| & cylindrical radial ($s$-) component  \\ \hline
 \verb|magnitude| & magnitude of vector  \\ \hline
\end{tabular}
\end{center}
\end{table}
%
\subsubsection{Control data} \label{section:section_control}
The format of the control file or block for cross sections is described below. The detail of each block is described in section \ref{section:def_control}.  \verb|cross_section_ctl| block can be read from an external file. To define the external file name, as \verb|file cross_section_ctl [file name]| in \verb|control_MHD| or \verb|control_snapshot|. \\
\\
%
Block \verb|cross_section_ctl| (Top level for sectioning)
\label{href_i:cross_section_ctl}
\begin{itemize}
	\item \hyperref[href_t:section_file_prefix]
			{\tt section\_file\_prefix    [section\_prefix]}
	\item \hyperref[href_t:psf_output_type]
			{\tt psf\_output\_type        [file\_format]}
	\item Block \hyperref[href_t:surface_define]{\tt surface\_define}
		\begin{itemize}
			\item \hyperref[href_t:section_method]
				{\tt section\_method    [METHOD]}
			\item Array \hyperref[href_t:psf_coefs_ctl]
				{\tt coefs\_ctl        [TERM]         [COEFFICIENT]}
			\item \hyperref[href_t:psf_radius]{\tt radius    [SIZE]}
			\item Array \hyperref[href_t:psf_normal_vector]
				{\tt normal\_vector    [DIRECTION]    [COMPONENT]}
			\item Array \hyperref[href_t:psf_axial_length]
                {\tt axial\_length     [DIRECTION]    [COMPONENT]}
			\item Array \hyperref[href_t:psf_center_position]
                {\tt center\_position  [DIRECTION]    [COMPONENT]}
%
			\item Array \hyperref[href_t:section_area_ctl]
				{\tt section\_area\_ctl        [AREA\_NAME]}
	\end{itemize}
%
	\item \hyperref[href_t:output_field_define]{\tt output\_field\_define}
		\begin{itemize}
			\item Array \hyperref[href_t:psf_output_field]
                {\tt output\_field     [FIELD]    [COMPONENT]}
		\end{itemize}
\end{itemize}

\subsubsection{Output data format of sectioning module}
\label{sec:PSF_data}
Sectioning data are written with VTK format and VTK data compressed by zlib. Field data also output by binary format and binary compressed by zlib. The list of data format and control flag for \verb|psf_output_type| are listed in Table \ref{table:PSF_data}. In the binary data format, position data and field data are saved independently not to write the grid data for each output step. Program \hyperref[section:psf_to_VTK]{\tt psf\_to\_VTK} generates VTK file from the binary section data. The output data format is defined by \verb|psf_output_type|. Because the field data is written by using Cartesian coordinate $(x,y,z)$ system, $(x,y,z)$ components in ParaView corresponds to the spherical components $(r, \theta, \phi)$ or cylindrical componennts $(s,\phi, z)$ if sectioning data is writtein the spherical or cylindrical componnents. Consequently, ParaView can not draw griph or field lines for these spherical or cylindrical vectors.
%
\begin{table}[htp]
\caption{Data format for sectioning data}
\label{table:PSF_data}
\begin{center} 
\begin{tabular}{|c|c|c|c|}
\hline
\verb|fld_format| & File format & \verb|extension| & Application \\ \hline \hline
\verb|VTK| & VTK & .vtk & ParaView \\ \hline
\verb|VTK_gzip| & Compressed VTK & .vtk.gz & ParaView \\
& & & after expanding by {\tt gzip}  \\ \hline
\verb|PSF| & Binary & 0.sgd (grid data) & - \\
           &        &  .sdt (field data) & - \\ \hline
\verb|PSF_gzip| & Compressed binary & .sgd.gz (grid data) & - \\
           &        &  .sdt.gz (field data) & - \\ \hline
\end{tabular}
\end{center} 
\end{table} 

%
\subsection{Isosurface data}
\label{section:ISO}
%
Calypso can also output isosurface data for visualization. Generally, data size of the isosurface is much larger than the sectioning data. The isosurface data is also written as a unstructured grid data with VTK format. The isosurface also consists of triangle patches.

To output cross sectioning, increment of the surface output data should be defined by \verb|i_step_isosurface_ctl| in \verb|time_step_ctl| block. And, array block \verb|isosurface_ctl| in \verb|visual_control| section is required to define cross sections. Each \verb|isosurface_ctl| block defines one cross section. Each cross section can also define by an external file by specifying external file name with \verb|file| label.
%
\subsubsection{Control data}  \label{section:isosurface_control}
The format of the control file or block for isosurfaces is described below. The detail of each block is described in section \ref{section:def_control}.  \verb|isosurface_ctl| block can be read from an external file. To define the external file name, as \verb|file isosurface_ctl [file name]| in \verb|control_MHD| or \verb|control_snapshot|. \\
\\
%
Block \verb|isosurface_ctl|  (Top lebel of the control data)
\label{href_i:isosurface_ctl}
\begin{itemize}
	\item \hyperref[href_t:isosurface_file_prefix]
			{\tt isosurface\_file\_prefix    [file\_prefix]}
	\item \hyperref[href_t:iso_output_type]
			{\tt iso\_output\_type           [file\_format]}
%
	\item Block \hyperref[href_t:isosurf_define]{\tt isosurf\_define}
		\begin{itemize}
			\item \hyperref[href_t:isosurf_field]{\tt isosurf\_field    [FIELD]}
			\item \hyperref[href_t:isosurf_component]
						{\tt isosurf\_component    [COMPONENT]}
			\item \hyperref[href_t:isosurf_value]{\tt isosurf\_value    [VALUE]}
%
			\item Array \hyperref[href_t:isosurf_area_ctl]
						{\tt isosurf\_area\_ctl  [AREA\_NAME]}
		\end{itemize}
%
	\item Block \hyperref[href_t:field_on_isosurf]{\tt field\_on\_isosurf}
		\begin{itemize}
			\item \hyperref[href_t:result_type]{\tt result\_type    [TYPE]}
			\item \hyperref[href_t:result_value]{\tt result\_value    [VALUE]}
			\item Array \hyperref[href_t:iso_output_field]
						{\tt output\_field        [FIELD]    [COMPONENT]}
		\end{itemize}
\end{itemize}

\subsubsection{Output data format of isosurface module}
\label{sec:PSF_data}
Isosurface data are written with VTK format and VTK data compressed by zlib. Field data also output by binary format and binary compressed by zlib. The list of data format and control flag for \verb|iso_output_type| are listed in Table \ref{table:ISO_data}. Like as sectioning data, program \hyperref[section:psf_to_VTK]{\tt psf\_to\_VTK} generates VTK file from the binary section data. The output data format is defined by \verb|iso_output_type|. Because the field data is written by using Cartesian coordinate $(x,y,z)$ system, $(x,y,z)$ components in ParaView corresponds to the spherical components $(r, \theta, \phi)$ or cylindrical componennts $(s,\phi, z)$ if sectioning data is writtein the spherical or cylindrical componnents. Consequently, ParaView can not draw griph or field lines for these spherical or cylindrical vectors.
%
\begin{table}[htp]
\caption{Data format for isosurface data}
\label{table:ISO_data}
\begin{center} 
\begin{tabular}{|c|c|c|c|}
\hline
\verb|fld_format| & File format & \verb|extension| & Application \\ \hline \hline
\verb|VTK| & VTK & .vtk & ParaView \\ \hline
\verb|VTK_gzip| & Compressed VTK & .vtk.gz & ParaView \\
& & & after expanding by {\tt gzip}  \\ \hline
\verb|ISO| & Binary & .sfm & - \\ \hline
\verb|ISO_gzip| & Compressed binary &  .sfm.gz & - \\ \hline
\end{tabular}
\end{center} 
\end{table} 



\subsection{Mean square amplitude data}
This program output mean square amplitude of the fields which is marked as \verb|Monitor_ON| over the fluid shell at every \verb|[increment_monitor]| steps. The data is written in the file \verb|[vol_pwr_prefix]_s.dat| or  \verb|sph_pwr_volume_s.dat| if  \verb|[vol_pwr_prefix]| is not defined in the control file. For vector fields, For the velocity $\bvec{u}$ and magnetic field $\bvec{B}$, the kinetic energy $1/2 u^{2}$ and magnetic energy $1/2 B^{2}$ are calculated instead of mean square amplitude. Labels on the first lines indicate following data. The data file have the following headers in the first 7 lines, and headers of the data and data are stored in the following lines. The header in the first 7 lines is the following. If these mean square amplitude data files exist before starting the simulation, programs append results at the end of files without checking constancy of the number of data and order of the field. If you change the configuration of data output structure, please move the existed data files to another directory before starting the programs.
%
\begin{description}
\item{\tt  line 2: } Number of radial grid and truncation level
\item{\tt  line 4: } radial layer ID for ICB and CMB
\item{\tt  line 6: } Number of field of data, total number of components
\item{\tt  line 7: } Number of components for each field
\end{description}
%
Labels for data indicates as
%
\begin{description}
\item{\tt  t\_step}  Time setp number
\item{\tt  time}   Time
\item{\tt  K\_ene\_pol}  Amplitude of poloidal kinetic energy
\item{\tt  K\_ene\_tor}  Amplitude of toroidal kinetic energy
\item{\tt  K\_ene}       Amplitude of total kinetic energy
\item{\tt  M\_ene\_pol}  Amplitude of poloidal magnetic energy
\item{\tt  M\_ene\_tor}  Amplitude of toroidal magnetic energy
\item{\tt  M\_ene}       Amplitude of total magnetic energy
\item{\tt  [Field]\_pol} Mean square amplitude of poloidal component of {\tt [Field]}
\item{\tt  [Field]\_tor} Mean square amplitude of toroidal component of {\tt [Field]}
\item{\tt  [Field]}      Mean square amplitude of {\tt [Field]}
\end{description}
%
\subsubsection{Volume average data}
Volume average data are written by defining {\tt volume\_average\_prefix} in control file. Volume average data are written in \verb|[vol_ave_prefix].dat| with same format as RMS amplitude data. If you need the sphere average data for specific radial point, you can use picked spectrum data for $l = m = 0$ at specific radius.

\subsubsection{Volume spectrum data}
Volume spectrum data are written by defining {\tt volume\_pwr\_spectr\_prefix} in control file. By defining {\tt volume\_pwr\_spectr\_prefix}, following spectrum data averaged over the fluid shell is written. Data format is the same as the volume mean square data, but degree $l$, order $m$, or meridional wave number $l-m$ is added in the list of data. \\
%
\begin{description}
\item{\tt [vol\_pwr\_prefix\_l.dat}  Volume average of mean square amplitude of the fields as a function of spherical harmonic degree $l$. For scalar field, the spectrum is
%
\begin{eqnarray}
f_{sq}(l) &=& \frac{1}{V} \sum_{m=-l}^{m=l} \int \left({f_{l}^{m}} \right)^{2} dV.
\nonumber
\end{eqnarray}
%
For vector field, spectrum for the poloidal and toroidal components are written by 
%
\begin{eqnarray}
B_{Ssq}(l) &=& \frac{1}{V} \sum_{m=-l}^{m=l} \int \left(\bvec{B}_{Sl}^{\ m} \right)^{2} dV,
\nonumber \\
B_{Tsq}(l) &=& \frac{1}{V} \sum_{m=-l}^{m=l} \int \left(\bvec{B}_{Tl}^{\ m} \right)^{2} dV.
\nonumber
\end{eqnarray}

If the vector field $\bvec{F}$ is not solenoidal (i.e. $\nabla \cdot \bvec{F} \neq 0$), The poloidal component of mean square data are included mean square field of the potential components as
%
\begin{eqnarray}
F_{Ssq}(l) &=& \frac{1}{V} \sum_{m=-l}^{m=l} \int \left[\left(\bvec{B}_{Sl}^{\ m} \right)^{2}
 + \left(-\nabla \phi_{Fl}^{\ m} \right)^{2} \right] dV.
\nonumber
\end{eqnarray}
%

%
\item{\tt [vol\_pwr\_prefix]\_m.dat} Volume average of mean square amplitude of the fields as a function of spherical harmonic order $m$. The zonal wave number is referred in this spectrum data. For scalar field, the spectrum is
\begin{eqnarray}
f_{sq}(m) &=& \frac{1}{V} \sum_{l=0}^{l=m} \int \left[ \left(f_{l}^{m} \right)^{2}
 + \left( f_{l}^{-m} \right)^{2} \right] dV.
\nonumber
\end{eqnarray}
For vector field, spectrum for the poloidal and toroidal components are written by 
\begin{eqnarray}
B_{Ssq}(m) &=& \frac{1}{V} \sum_{l=0}^{l=m} \int \left[\left(\bvec{B}_{Sl}^{\ m} \right)^{2} 
 + \left(\bvec{B}_{Sl}^{\ -m} \right)^{2}  \right] dV,
\nonumber \\
B_{Tsq}(m) &=& \frac{1}{V} \sum_{l=0}^{l=m} \int \left[\left(\bvec{B}_{Tl}^{\ m} \right)^{2} 
 + \left(\bvec{B}_{Tl}^{\ -m} \right)^{2}  \right] dV.
\nonumber
\end{eqnarray}

\item{\tt [vol\_pwr\_prefix]\_lm.dat} Volume average of mean square amplitude of the fields as a function of spherical harmonic order $n = l-m$. The wave number in the latitude direction is referred in this spectrum data. For scalar field, the spectrum is
\begin{eqnarray}
f_{sq}(n) &=& \frac{1}{V} \sum_{l=n}^{l=l-n} \int \left[ \left(f_{l}^{l-n}\right)^{2} + \left(f_{l}^{-l+n}\right)^2 \right] dV.
\nonumber
\end{eqnarray}
For vector field, spectrum for the poloidal and toroidal components are written by 
\begin{eqnarray}
B_{Ssq}(n) &=& \frac{1}{V} \sum_{l=n}^{l=l-n} \int  \left[\left(\bvec{B}_{Sl}^{\ l-n} \right)^{2} 
 + \left(\bvec{B}_{Sl}^{\ -l+n} \right)^{2}  \right]  dV,
\nonumber \\
B_{Tsq}(n) &=& \frac{1}{V} \sum_{l=n}^{l=l-n} \int \left[\left(\bvec{B}_{Tl}^{\ l-n} \right)^{2} 
 + \left(\bvec{B}_{Tl}^{\ -l+n} \right)^{2}  \right] dV.
\nonumber
\end{eqnarray}

\end{description}

%
\subsubsection{Layered spectrum data}
\label{section:layerd_spectr}
Spectrum data for the each radial position are written by defining {\tt layered\_pwr\_spectr\_prefix} in control file. By defining {\tt layered\_pwr\_spectr\_prefix}, following spectrum data averaged over the fluid shell is written. Data format is the same as the volume spectrum data, but radial grid point and radius of the layer is added in the list. The following files are generated. The radial points for output is listed in the array \verb|spectr_layer_ctl|. If \verb|spectr_layer_ctl| is not defined, mean square data at {\bf all} radial levels will be written. See example of \hyperref[section:dynamobench]{dynamo benchmark case 2}.
%
\begin{description}
\item{\tt [layer\_pwr\_prefix]\_s.dat} Surface average of mean square amplitude of the fields.
\item{\tt [layer\_pwr\_prefix]\_l.dat} Surface average of mean square amplitude of the fields as a function of spherical harmonic degree $l$ and radial grid id $k$. For scalar field, the spectrum is
\begin{eqnarray}
f_{sq}(k,l) &=& \frac{1}{S} \sum_{m=-l}^{m=l} \int \left({f_{l}^{m}} \right)^{2} dS.
\nonumber
\end{eqnarray}
For vector field, spectrum for the poloidal and toroidal components are written by 
\begin{eqnarray}
B_{Ssq}(k,l) &=& \frac{1}{S} \sum_{m=-l}^{m=l} \int \left(\bvec{B}_{Sl}^{\ m} \right)^{2} dS,
\nonumber \\
B_{Tsq}(k,l) &=& \frac{1}{S} \sum_{m=-l}^{m=l} \int \left(\bvec{B}_{Tl}^{\ m} \right)^{2} dS.
\nonumber
\end{eqnarray}

\item{\tt [layer\_pwr\_prefix]\_m.dat} Surace average of mean square amplitude of the fields as a function of spherical harmonic order $m$ and radial grid id $k$. The zonal wave number is referred in this spectrum data. For scalar field, the spectrum is
\begin{eqnarray}
f_{sq}(k,m) &=& \frac{1}{S} \sum_{l=m}^{l=L} \int \left[ \left(f_{l}^{m} \right)^{2}
 + \left( f_{l}^{-m} \right)^{2} \right] dS.
\nonumber
\end{eqnarray}
For vector field, spectrum for the poloidal and toroidal components are written by 
\begin{eqnarray}
B_{Ssq}(k,m) &=& \frac{1}{S} \sum_{l=m}^{l=L} \int \left[\left(\bvec{B}_{Sl}^{\ m} \right)^{2} 
 + \left(\bvec{B}_{Sl}^{\ -m} \right)^{2}  \right] dS,
\nonumber \\
B_{Tsq}(k,m) &=& \frac{1}{S} \sum_{l=m}^{l=L} \int \left[\left(\bvec{B}_{Tl}^{\ m} \right)^{2} 
 + \left(\bvec{B}_{Tl}^{\ -m} \right)^{2}  \right] dS.
\nonumber
\end{eqnarray}

\item{\tt [layer\_pwr\_prefix]\_lm.dat} Surface average of mean square amplitude of the fields as a function of spherical harmonic order $n = l-m$ and radial grid id $k$. The wave number in the latitude direction is referred in this spectrum data. For scalar field, the spectrum is
\begin{eqnarray}
f_{sq}(k,n) &=& \frac{1}{S} \sum_{l=n}^{l=L} \int \left[ \left(f_{l}^{l-n}\right)^{2} + \left(f_{l}^{-l+n}\right)^2 \right] dS.
\nonumber
\end{eqnarray}
For vector field, spectrum for the poloidal and toroidal components are written by 
\begin{eqnarray}
B_{Ssq}(k,n) &=& \frac{1}{S} \sum_{l=n}^{l=L} \int  \left[\left(\bvec{B}_{Sl}^{\ l-n} \right)^{2} 
 + \left(\bvec{B}_{Sl}^{\ -l+n} \right)^{2}  \right] dS,
\nonumber \\
B_{Tsq}(k,n) &=& \frac{1}{S} \sum_{l=n}^{l=L} \int \left[\left(\bvec{B}_{Tl}^{\ l-n} \right)^{2} 
 + \left(\bvec{B}_{Tl}^{\ -l+n} \right)^{2}  \right] dS.
\nonumber
\end{eqnarray}

\end{description}
%

\subsection{Volume average data {\tt [volume\_average\_prefix].dat}}
The volume average information is written in the file {\tt [volume\_average\_prefix].dat}.
The volume average is evaluated by the radial integration of $l = m = 0$ component of the spherical harmonics coefficients as
\begin{eqnarray}
f_{ave} &=& \frac{1}{V} \int f_{0}^{0}(r) 4 \pi r^{2} dr.
\end{eqnarray}
Consequently, volume average of the solenoidal vector field to be 0, but but average data for the solenoidal vector is also written in the data to share the data IO routine with other monitor data output. To ouytput the average value over the specific radial level, use spectrum monitor data output \hyperref[sec:pickup_spectr_ctl]{\tt pickup\_spectr\_ctl} with $l = m = 0$.

\subsection{Gauss coefficient data {\tt [gauss\_coef\_prefix].dat}}
This program output selected Gauss coefficients of the magnetic field. Gauss coefficients is evaluated for radius defined by \verb|[gauss_coef_radius]| every \verb|[increment_monitor]| steps. Gauss coefficients are evaluated by using poloidal magnetic field at CMB $B_{Sl}^{\ m}(r_{o})$ and radius defined by \verb|[gauss_coef_radius]| $r_{e}$ as
%
\begin{eqnarray}
g_{l}^{m} &=& \frac{l}{r_{e}^2} \left(\frac{r_{o}}{r_{e}}\right)^{l} B_{Sl}^{\ m}(r_{o}),
\nonumber \\
h_{l}^{m} &=& \frac{l}{r_{e}^2} \left(\frac{r_{o}}{r_{e}}\right)^{l} B_{Sl}^{\ -m}(r_{o}).
\nonumber
\end{eqnarray}
%
The data file has the following headers in the first three lines,
%
\begin{description}
\item{\tt  line 2: } Number of saved Gauss coefficients and reference radius.
\item{\tt  line 3: } Labels of Gauss coefficients data.
\end{description}
%
The data consists of time step, time, and Gauss coefficients for each step in one line. If the Gauss coefficients data file exist before starting the simulation, programs append Gauss coefficients at the end of files without checking constancy of the number of data and order of the field. If you change the configuration of data output structure, please move the old Gauss coefficients file to another directory before starting the programs.

\subsection{Spectrum monitor data {\tt [picked\_sph\_prefix].dat}}
\label{sec:pickup_spectr_ctl}
This program outputs spherical harmonics coefficients at specified spherical harmonics modes and radial points in single text file. Spectrum data marked \verb|[Monitor_On]| are written in our line for each spherical harmonics mode and radial point every \\
\verb|[increment_monitor]| steps. If the spectrum monitor data file exist before starting the simulation, programs append spectrum data at the end of files without checking constancy of the number of data and order of the field. If you change the configuration of data output structure, please move the old spectrum monitor file to another directory before starting the programs.

If a vector field $\bvec{F}$ is not a solenoidal field, $\bvec{F}$ is described by the spherical harmonics coefficients of the poloidal $F_{Sl}^{\ m}$, toroidal $F_{Tl}^{\ m}$, and potential $\varphi_{l}^{m}$ components as
\begin{eqnarray}
\bvec{F}(r, \theta, \phi) & = &  - \frac{1}{r^{2}}\frac{\partial \varphi_{0}^{0}}{\partial r} \hat{r}
 + \sum_{l=1}^{L} \sum_{m=-l}^{l} 
\left[\nabla \times \nabla \times \left( F_{Sl}^{\ m} \hat{r} \right) +  \nabla \times \left(F_{Tl}^{\ m}\right)
 - \nabla \left(\varphi_{l}^{m} Y_{l}^{m} \right)\right].
\nonumber
\end{eqnarray}
In Calypso, the following coefficients are written for the non-solenoidal vector.
\begin{description}
\item{\tt  $\verb|[field_name]_pol|$ : }
 $\left\{\begin{array}{ccr}
\displaystyle{
F_{Sl}^{\ m} - \frac{r^{2}}{l \left(l+1\right)} \frac{\partial \varphi_{l}^{m}}{\partial r} }
& \mbox{for} & \left (l \ne 0 \right)\\
\displaystyle{
 -r^{2} \frac{\partial \varphi_{0}^{0}}{\partial r}
} & \mbox{for} & \left (l = 0 \right)
\end{array}
\right.$
\item{\tt  $\verb|[field_name]_dpdr|$ : } 
$
\left\{
\begin{array}{ccr}
\displaystyle{
\frac{\partial F_{Sl}^{\ m}}{\partial r} - \varphi_{l}^{m}}
 & \mbox{for} & \left (l \ne 0 \right)\\
 0 & \mbox{for} & \left (l = 0 \right)
\end{array}
\right. $
\item{\tt  $\verb|[field_name]_tor|$ : }  $F_{Tl}^{\ m}$
\end{description}


\subsection{Nusselt number data {\tt [nusselt\_number\_prefix].dat}}
{\bf CAUTION: Nusselt number is not evaluated if heat source is exsist.}
The Nusselt number Nu at CMB and ICB is written for each step in one line. The Nusselt number is evaluated by
%
\begin{eqnarray*}
Nu = \frac{<\partial T / \partial r>}{\partial T_{diff}/ \partial r},
\end{eqnarray*}
where, $<\partial T / \partial r>$ and $T_{diff}$ are the horizontal average of the temperature gradient at ICB and CMB and diffusive temperature profile, respectively. $T_{diff}$ is evaluated without heat source, as
\begin{eqnarray*}
T_{diff} = \frac{r_{o}T_{o} - r_{i}T_{i}}{r_{o} - r_{i}}
    +  \frac{r_{o}r_{i}\left(T_{i} - T_{o}\right)}{r_{o} - r_{i}} \frac{1}{r}.
\end{eqnarray*}
%
This diffusive temperature profile is for the case without heat source in the fluid. If simulation is performed including the heat source, this data file does not written.
If the Nusselt number data file exist before starting the simulation, programs append spectrum data at the end of files without checking constancy. If you change the configuration of data output structure, please move the old spectrum monitor file to another directory before starting the programs.


\newpage
\section{Data transform program ({\tt sph\_snapshot})}
\label{section:sph_snapshot}
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{images/flow_3}
\end{center}
\caption{Data flow for data transform program.}
\label{fig:flow_3}
\end{figure}
%
Simulation program outputs spectrum data as a whole field data. This program is made from simulation program by replacing from time integration routines to restart data input routine. Consequently, Input/Output files in Table \ref{table:sph_mhd} are the same for {\tt sph\_snapshot}, except for the required input restart data \verb|[rst_prefix].[step #].[rst_extension]|.
%
This program requires control file \verb|control_snapshot| insteacd of \verb|control_mhd|. File format of the control file is same as the control field for simulation \hyperref[href_i:MHD_control]{\tt control\_MHD}.

The same files as the simulation program are read in this program, and field data are generated from the snapshots of spectrum data. The monitoring data for snapshots can also be generated. \verb|[step #]| is added in the file name, and the \verb|[step #]| is calculated by \verb|time step|/\verb|[ISTEP_FIELD]|.

We recommend to output cross section data at $y = 0$ by using sectioning module (see \ref{section:PSF}) for zonal mean snapshot program \verb|sph_zm_snapshot| to reduce data size.

\newpage
\section{Initial field generation program \\
({\tt sph\_initial\_field})}
\label{sec:sph_initial_field}
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{images/flow_ini}
\end{center}
\caption{Data flow for initial field generation program.}
\label{fig:flow_ini}
\end{figure}
%
 The initial fields for dynamo benchmark can set in the simulation program by setting \verb|[INITIAL_TYPE]| flag. This program is used to generate initial field by user.  The heat source $q_{T}$ and light element source $q_{C}$ are also defined by this program because $q_{T}$ and $q_{C}$ are defined as scalar fields. Spherical harmonics indexing data files are also generated by using information in \verb|spherical_shell_ctl| block if these indexing data files do not exist. The Fortran source file to define initial field \\
 \verb|const_sph_initial_spectr.f90| is saved in \verb|src/programs/data_utilities| \\
 \verb|/INITIAL_FIELD/| directory,  and please compile again after modifying this module. This program also needs the files listed in Table \ref{table:inital_fld}.
%
\begin{table}[htp]
\caption{List of files for simulation {\tt sph\_initial\_field} }
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
 name & Parallelization & I/O \\ \hline \hline
\verb|control_MHD| & Serial & Input \\ \hline
\verb|[sph_prefix].[rj_extension]|  & - & Input/(Output) \\
\verb|[sph_prefix].[rlm_extension]| & - & Input/(Output) \\
\verb|[sph_prefix].[rtm_extension]| & - & Input/(Output) \\
\verb|[sph_prefix].[rtp_extension]| & - & Input/(Output) \\ \hline
\verb|[rst_prefix].[step #].[rst_extension]| & - & Input/Output  \\ \hline
\end{tabular}
\end{center}
(Output): Marked files are generated if files do not exist.
\label{table:inital_fld}
\end{table}
%
This program generates the spectrum data files \verb|[rst_prefix].[step #].[rst_extension]|. To use generated initial data file, please set 
 \hyperref[href_t:i_step_init_ctl]{{\tt [ISTEP\_START]}} to be 0 and \hyperref[href_t:restart_file_ctl]{{\tt [INITIAL\_TYPE]}} to be \\\hyperref[href_t:restart_file_ctl]{{\tt start\_from\_rst\_file}}.

\subsection{Definition of the initial field}
\label{sec:def_initial}
To construct Initial field data, you need to edit the source code \verb|const_sph_initial_spectr.f90| in \verb|src/programs/data_utilities/INITIAL_FIELD/| directory. The module \verb|const_sph_initial_spectr| consists of the following subroutines:
%
\begin{description}
\item{\verb|sph_initial_spectrum|:}    Top subroutine to construct initial field.
\item{\verb|set_initial_velocity|:}        Routine to construct initial velocity.
\item{\verb|set_initial_temperature|:} Routine to construct initial temperature.
\item{\verb|set_initial_composition|:} Routine to construct initial composition.
\item{\verb|set_initial_magne_sph|:} Routine to construct initial magnetic field.
\item{\verb|set_initial_heat_source_sph|:} Routine to construct heat source.
\item{\verb|set_initial_light_source_sph|:}  Routine to construct composition source.
\end{description}
%
The construction routine for each field are called from the top routine \\
\verb|const_sph_initial_spectr.f90|. If lines to call subroutines are commented out, corresponding initial fields are set to 0. In addition, the initial fields to be constructed need to be defined by \verb|nod_value_ctl| array in the \verb|control_MHD|.
%
\begin{table}[htp]
\caption{Field name and corresponding field id in Calypso}
\begin{center}
\begin{tabular}{|c|c|cc|}
\hline
field name & scalar & poloidal  & toroidal  \\ \hline
Velocity & - & \verb|ipol%i_velo| &   \verb|itor%i_velo| \\ 
Magnetic field & - & \verb|ipol%i_magne| &  \verb|itor%i_magne| \\ 
Current density & - & \verb|ipol%i_current| &  \verb|itor%i_current| \\ 
Temperature & \verb|ipol%i_temp| & - & - \\ 
Composition & \verb|ipol%i_light| & - & - \\ 
Heat source & \verb|ipol%i_heat_source| & - & - \\ 
Composition source & \verb|ipol%i_light_source| & - & - \\ \hline
\end{tabular}
\end{center}
\label{table:field_point}
\end{table}%
% 

Initial fields need to be defined by the spherical harmonics coefficients at each radial points as array \verb|d_rj(i,i_field)|, where \verb|i| and \verb|i_field| are the local address of the spectrum data and field id, respectively. The address of the fields are listed in Table \ref{table:field_point}.

In Calypso, local data address for each MPI process is used for the spectrum data address \verb|i|. To find the local address \verb|i|, two functions are required. \\
First, \verb|j = find_local_sph_mode_address(l,m)| returns the local spherical  harmonics address \verb|j| from aa spherical harmonics mode $Y_{l}^{m}$. If process does not have the data for $Y_{l}^{m}$, \verb|j| is set to 0. Second, \verb|i = local_sph_data_address(k,j)| returns the local data address \verb|i| from radial grid number \verb|k| and local spherical harmonics id \verb|j|. For do loops in the radial direction, the total number of radial grid points, radial address for ICB, and radial address for CMB are defined as \verb|nidx_rj(1)|, \verb|nlayer_ICB|, and \verb|nlayer_CMB|, respectively. The radius for the \verb|k|-th grid points can be obtained by \verb|r = radius_1d_rj_r(k)|. The subroutines to define initial temperature for the dynamo benchmark Case 1 is shown below as an example.

After updating the source code, the program \verb|sph_initial_field| needs to be updated. To update the program, move to the work directory \verb|[CALYPSO_HOME]/work| and run make command as
% 
\begin{verbatim}
% cd \verb|[CALYPSO_HOME]/work|
% make
\end{verbatim}
%
Then, the program  \verb|sph_initial_field| and  \verb|sph_add_initial_field| are updated.

%
\begin{verbatim}
!
      subroutine set_initial_temperature
!
      use m_sph_spectr_data
!
      integer ( kind = kint) :: inod, k, jj
      real (kind = kreal) :: pi, rr, xr, shell
      real(kind = kreal), parameter :: A_temp = 0.1d0
!
!
!$omp parallel do
      do inod = 1, nnod_rj
        d_rj(inod,ipol%i_temp) = zero
      end do
!$omp end parallel do
!
      pi = four * atan(one)
      shell = r_CMB - r_ICB
!
!   search address for (l = m = 0)
      jj = find_local_sph_mode_address(0, 0)
!
!   set reference temperature if (l = m = 0) mode is there
      if (jj .gt. 0) then
        do k = 1, nlayer_ICB-1
          inod = local_sph_data_address(k,jj)
          d_rj(inod,ipol%i_temp) = 1.0d0
        end do
        do k = nlayer_ICB, nlayer_CMB
          inod = local_sph_data_address(k,jj)
          d_rj(inod,ipol%i_temp) = (ar_1d_rj(k,1) * 20.d0/13.0d0        &
     &                              - 1.0d0 ) * 7.0d0 / 13.0d0
        end do
      end if
!
!
!    Find local addrtess for (l,m) = (4,4)
      jj =  find_local_sph_mode_address(4, 4)
!      jj =  find_local_sph_mode_address(5, 5)
!
!    If data for (l,m) = (4,4) is there, set initial temperature
      if (jj .gt. 0) then
!    Set initial field from ICB to CMB
        do k = nlayer_ICB, nlayer_CMB
!
!    Set radius data
          rr = radius_1d_rj_r(k)
!    Set 1d address to substitute at (Nr, j)
          inod = local_sph_data_address(k,jj)
!
!    set initial temperature
          xr = two * rr - one * (r_CMB+r_ICB) / shell
          d_rj(inod,ipol%i_temp) = (one-three*xr**2+three*xr**4-xr**6)  &
     &                            * A_temp * three / (sqrt(two*pi))
        end do
      end if
!
!    Center
      if(inod_rj_center .gt. 0) then
        jj = find_local_sph_mode_address(0, 0)
        inod = local_sph_data_address(1,jj)
        d_rj(inod_rj_center,ipol%i_temp) = d_rj(inod,ipol%i_temp)
      end if
!
      end subroutine set_initial_temperature
!
\end{verbatim}
%

\section{Initial field modification program \\
({\tt sph\_add\_initial\_field})}
\label{sec:add_initial_field}
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{images/flow_ini}
\end{center}
\caption{Data flow for initial field modification program.}
\label{fig:flow_add_ini}
\end{figure}
%
{\bf Caution: This program overwrites existing initial field data. Please run it after taking a backup.} \\

 This program modifies or adds new data to an initial field file. It could be used to start a new geodynamo simulation by adding seed magnetic field or source terms to a non-magnetic convection simulation. The initial fields to be added are also defined in \verb|const_sph_initial_spectr.f90|. \verb|data_utilities/INITIAL_FIELD/| directory. This program also needs the files listed in Table \ref{table:add_inital_fld}.
%
\begin{table}[htp]
\caption{List of files for simulation {\tt sph\_add\_initial\_field} }
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
 name & Parallelization & I/O \\ \hline \hline
\verb|control_MHD| & Serial & Input \\ \hline
\verb|[sph_prefix].[rj_extension]|  & - & Input / (Output) \\
\verb|[sph_prefix].[rlm_extension]| & - & Input / (Output)  \\
\verb|[sph_prefix].[rtm_extension]| & - & Input / (Output)  \\
\verb|[sph_prefix].[rtp_extension]| & - & Input / (Output)  \\ \hline
\verb|[rst_prefix].[step #].[rst_extension]| & - & Input/Output  \\ \hline
\end{tabular}
\end{center}
(Output): Marked files are generated if files do not exist.
\label{table:add_inital_fld}
\end{table}
%
This program generates the spectrum data files \verb|[rst_prefix].[step#].[rst_extension]|. To use generated initial data file, set 
 \hyperref[href_t:i_step_init_ctl]{{\tt [ISTEP\_START]}} and \verb|[ISTEP_RESTART]| to be appropriate time step and increment, respectively.
To read the original initial field data, \hyperref[href_t:restart_file_ctl]{{\tt [INITIAL\_TYPE]}} is set to be \hyperref[href_t:restart_file_ctl]{{\tt start\_from\_rst\_file}} in \verb|control_MHD|. In other words, the \verb|[step #]| in the file name, \hyperref[href_t:i_step_init_ctl]{{\tt [ISTEP\_START]}}, and \verb|[ISTEP_RESTART]| in the control file should be the consistent.

This program also uses the module file \verb|const_sph_initial_spectr.f90| to define the initial field. The initial fields are defined as following the previous section \ref{sec:def_initial}. After updating the source code, the program \verb|sph_initial_field| needs to be updated. After modifying  \verb|const_sph_initial_spectr.f90|, the program is build by make command in  the work directory \verb|[CALYPSO_HOME]/work|.

\section{Check program for dynamo benchmark \\
({\tt sph\_dynamobench})}
This program is only used to check solution for dynamo benchmark by Christensen {\it et. al}. The following files are used for this program.

\begin{table}[htp]
\caption{List of files for dynamo benchmark check {\tt sph\_dynamobench} }
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
 name & Parallelization & I/O \\ \hline \hline
\verb|control_snapshot| & Serial & Input \\ \hline
\verb|[sph_prefix].[rj_extension]|  & - & Input \\
\verb|[sph_prefix].[rlm_extension]| & - & Input \\
\verb|[sph_prefix].[rtm_extension]| & - & Input \\
\verb|[sph_prefix].[rtp_extension]| & - & Input \\ \hline
\verb|[rst_prefix].[step#].[rst_extension]| &  - & Input  \\ \hline
\verb|dynamobench.dat| & Single & Output \\ \hline
\end{tabular}
\end{center}
\label{table:sph_dynamobench}
\end{table}

\subsection{Dynamo benchmark data {\tt dynamobench.dat}}
 In benchmark test by Christensen {\it et. al.}, both global values and local values are checked. As global results, Kinetic energy 
 $\displaystyle{ \frac{1}{V} \int \frac{1}{2} u^{2} dV}$ in the fluid shell, magnetic energy in the fluid shell 
 $\displaystyle{ \frac{1}{V} \frac{1}{E Pm} \int \frac{1}{2} B^{2} dV}$ (for case 1 and 2), and magnetic energy in the solid inner sphere 
 $\displaystyle{ \frac{1}{V_{i}} \frac{1}{E Pm} \int \frac{1}{2} B^{2} dV_{i}}$ (for case 2 only). Benchmark also requests 
 By increasing number of grid point at mid-dpeth of the fluid shell in the equatorial plane by \hyperref[href_t:nphi_mid_eq_ctl]{{\tt nphi\_mid\_eq\_ctl}}, program can find accurate solution for the point where $u_{r} = 0$ and $\partial u_{r} / \partial \phi > 0$. Angular frequency of the field pattern with respect to the $\phi$ direction is also required. The benchmark test also requires temperature and $\theta$ component of velocity. In the text file {\tt dynamobench.dat}, the following data are written in one line for every \verb|[i_step_rst_ctl]| step.
%
\begin{description}
\item{\tt t\_step:  }  Time step number
\item{\tt time:     }  Time
\item{\tt KE\_pol:   }  Poloidal kinetic energy
\item{\tt KE\_tor:   }  Toroidal kinetic energy
\item{\tt KE\_total: }  Total kinetic energy
\item{\tt ME\_pol:   }  Poloidal magnetic energy  (Case 1 and 2)
\item{\tt ME\_tor:   }  Toroidal magnetic energy  (Case 1 and 2)
\item{\tt ME\_total: }  Total magnetic energy  (Case 1 and 2)
\item{\tt ME\_pol\_ic:      }  Poloidal magnetic energy in inner core  (Case 2)
\item{\tt ME\_tor\_icore:   }  Toroidal magnetic energy in inner core (Case 2)
\item{\tt ME\_total\_icore: }  Total magnetic energy in inner core (Case 2)
\item{\tt omega\_ic\_z: } Angular velocity of inner core rotation (Case 2)
\item{\tt MAG\_torque\_ic\_z: }  Magnetic torque integrated over the inner core (Case 2)
\item{\tt phi\_1...4: } Longitude where $u_{r} = 0$ and $\partial u_{r} / \partial \phi > 0$ at mid-depth in equatorial plane.
\item{\tt omega\_vp44:} Drift frequency evaluated by $V_{S4}^{\ 4}$ component
\item{\tt omega\_vt54:} Drift frequency evaluated by $V_{T5}^{\ 4}$ component
\item{\tt B\_theta: } $\Theta$ component of magnetic field at requested point.
\item{\tt v\_phi: } $\phi$ component of velocity at requested point.
\item{\tt temp: } Temperature at requested point.


\end{description}

{\small 
\begin{verbatim}
t_step    time    KE_pol    KE_tor    KE_total    ME_pol    ME_t
or    ME_total    ME_pol_icore    ME_tor_icore    ME_total_icore
    omega_ic_z    MAG_torque_ic_z    phi_1    phi_2    phi_3    
phi_4    omega_vp44    omega_vt54    B_theta    v_phi    temp
     20000   9.999999999998981E-001   1.534059732073072E+001   2
.431439471284618E+001   3.965499203357688E+001   2.4056940119550
09E+000   1.648662987055900E+000   4.054356999010911E+000   3.90
8687924452961E+001   4.812865754441352E-001   3.956816581997376E
+001   5.220517005592486E+000  -2.321885847438682E+002   3.59417
5626663308E-001   1.930213889461227E+000   3.501010216256124E+00
0   5.071806543051021E+000   7.808553595635292E-001  -1.64958344
1437563E-001  -5.136522824340612E+000  -8.047915942925034E+000  
 3.752181234262930E-001
...
\end{verbatim}
}
%

\section{Sectioning program ({\tt sectioning})} \label{sec:sectioning}
This program generates cross sections and isosurfaces from FEM mesh data and field data using the sectioning and isosurface module in the simulation program {\tt sph\_mhd}. The data for this program is listed in Table \ref{table:sectioning}. This program run on the parallel environment, and needs to use the same number of MPI processes as the number of processes which is used for the simulation program. VTK and compressed VTK data is not supported for the input field data.
%
\begin{table}[htp]
\caption{List of files for sectioning {\tt sectioning} }
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
name & Parallelization & I/O \\ \hline \hline
\verb|control_viz| & Serial & Input \\ \hline
\verb|[mesh_prefix].[fem_extension]| & - & Input \\ \hline
\verb|[fld_prefix].[step#].[domain#].[extension]| & - & Input  \\ \hline
\verb|[section_prefix].[step#].[extension]| &  Single & Output  \\
\verb|[isosurface_prefix].[step#].[extension]| &  Single & Output  \\ \hline
\end{tabular}
\end{center}
\label{table:sectioning}
\end{table}
%

\subsection{Control file}
The format of the control file \verb|control_viz| is described below. The detail of each block is described in section \ref{section:def_control}. You can jump to detailed description by clicking each item". \\
\\
%
Block \verb|visualizer|  (Top block of the control file)
\label{href_i:visualizer}
%
\begin{itemize}
\item Block \hyperref[href_t:data_files_def]{\tt data\_files\_def}
	\label{href_i:data_files_def_v}
%
	\begin{itemize}
	\item \hyperref[href_t:num_subdomain_ctl]
			{\tt num\_subdomain\_ctl    [Num\_PE]}
	\item \hyperref[href_t:num_smp_ctl]
			{\tt num\_smp\_ctl    [Num\_Threads]}
	\item \hyperref[href_t:mesh_file_prefix]
			{\tt mesh\_file\_prefix    [mesh\_prefix]}
	\item \hyperref[href_t:field_file_prefix]
			{\tt field\_file\_prefix    [fld\_prefix]}
%
	\item \hyperref[href_t:mesh_file_fmt_ctl]
			{\tt mesh\_file\_fmt\_ctl    [mesh\_format]}
	\item \hyperref[href_t:field_file_fmt_ctl]
			{\tt field\_file\_fmt\_ctl    [fld\_format]}
	\end{itemize}
%
\item Block \hyperref[href_t:time_step_ctl]{\tt time\_step\_ctl}
	\begin{itemize} \label{href_i:time_step_ctl_v}
	\item \hyperref[href_t:i_step_init_ctl]
		{\tt i\_step\_init\_ctl        [ISTEP\_START]}
	\item \hyperref[href_t:i_step_finish_ctl]
		{\tt i\_step\_finish\_ctl      [ISTEP\_FINISH]}
	\item \hyperref[href_t:i_step_field_ctl]
		{\tt i\_step\_field\_ctl       [ISTEP\_FIELD]}
	\item \hyperref[href_t:i_step_sectioning_ctl]
		{\tt i\_step\_sectioning\_ctl  [ISTEP\_SECTION]}
	\item \hyperref[href_t:i_step_isosurface_ctl]
		{\tt i\_step\_isosurface\_ctl  [ISTEP\_ISOSURFACE]}
	\end{itemize}
%
\item Block \hyperref[href_t:visual_control]{\tt visual\_control}
    \begin{itemize} \label{href_i:visual_control_v}
    \item \hyperref[href_t:i_step_sectioning_ctl]
        {\tt i\_step\_sectioning\_ctl  [ISTEP\_SECTION]}
    \item Array \hyperref[href_t:cross_section_ctl]{\tt cross\_section\_ctl}
		\begin{itemize}
        \item File or Block {\tt cross\_section\_ctl} \\
                            {\tt [section\_control\_file]} \\
								(See section \ref{section:section_control})
		\end{itemize}
%
    \item \hyperref[href_t:i_step_isosurface_ctl]
		{\tt i\_step\_isosurface\_ctl  [ISTEP\_ISOSURFACE]}
    \item Array \hyperref[href_t:isosurface_ctl]{\tt isosurface\_ctl}
		\begin{itemize}
		\item File or Block {\tt isosurface\_ctl} \\
                            {\tt [isosurface\_control\_file]} \\
								(See section \ref{section:isosurface_control})
		\end{itemize}
    \end{itemize}
\end{itemize}
%

\section{Field data converter program ({\tt field\_to\_VTK})} \label{sec:field_to_VTK}
This program generates VTK data from FEM mesh data and field data. The data for this program is listed in Table \ref{table:fld_to_vtk}. This program run on the parallel environment, and needs to use the same number of MPI processes as the number of processes which is used for the simulation program.
%
\begin{table}[htp]
\caption{List of files for sectioning {\tt sectioning} }
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
name & Parallelization & I/O \\ \hline \hline
\verb|control_viz| & Serial & Input \\ \hline
\verb|[mesh_prefix].[fem_extension]| & - & Input \\ \hline
\verb|[fld_prefix].[step#].[domain#].[extension]| & - & Input  \\ \hline
\verb|[fld_prefix].[step#].[domain#].[vtk]| or [vtk.gz] & - & Output  \\ \hline
\end{tabular}
\end{center}
\label{table:sectioning}
\end{table}
%

\newpage
\subsection{Control file}
The format of the control file \verb|control_viz| is described below. The detail of each block is described in section \ref{section:def_control}. You can jump to detailed description by clicking each item". \\
\\
%
Block \verb|visualizer|  (Top block of the control file)
\label{href_i:visualizer}
%
\begin{itemize}
\item Block \hyperref[href_t:data_files_def]{\tt data\_files\_def}
	\label{href_i:data_files_def_f}
%
	\begin{itemize}
	\item \hyperref[href_t:num_subdomain_ctl]
			{\tt num\_subdomain\_ctl    [Num\_PE]}
	\item \hyperref[href_t:num_smp_ctl]
			{\tt num\_smp\_ctl    [Num\_Threads]}
	\item \hyperref[href_t:mesh_file_prefix]
			{\tt mesh\_file\_prefix    [mesh\_prefix]}
	\item \hyperref[href_t:field_file_prefix]
			{\tt field\_file\_prefix    [fld\_prefix]}
%
	\item \hyperref[href_t:mesh_file_fmt_ctl]
			{\tt mesh\_file\_fmt\_ctl    [mesh\_format]}
	\item \hyperref[href_t:field_file_fmt_ctl]
			{\tt field\_file\_fmt\_ctl    [fld\_format]}
	\end{itemize}
%
\item Block \hyperref[href_t:time_step_ctl]{\tt time\_step\_ctl}
	\begin{itemize} \label{href_i:time_step_ctl_f}
	\item \hyperref[href_t:i_step_init_ctl]
		{\tt i\_step\_init\_ctl        [ISTEP\_START]}
	\item \hyperref[href_t:i_step_finish_ctl]
		{\tt i\_step\_finish\_ctl      [ISTEP\_FINISH]}
	\item \hyperref[href_t:i_step_field_ctl]
		{\tt i\_step\_field\_ctl       [ISTEP\_FIELD]}
	\end{itemize}
%
\item Block \hyperref[href_t:visual_control]{\tt visual\_control}
    \begin{itemize} \label{href_i:visual_control_v}
    \item \hyperref[href_t:output_field_file_fmt_ctl]
		{\tt output\_field\_file\_fmt\_ctl  [VTK\_format]}
    \end{itemize}
\end{itemize}
%

\section{Section and isosurface data converter program ({\tt psf\_to\_VTK})} \label{section:psf_to_VTK}
This program generates VTK data from bindary sectioning and isosurface data. This program run on a single processor, and needs interactive input. The following is the console output of the program.

{\small
\begin{verbatim}
% /usr/local/Calypso/bin/psf_to_vtk 
Input file prefix
zm_y0									<- Input file prefix
Input file extension from following:
vtk, vtk.gz, vtd, vtd.gz, inp, inp.gz, udt, udt.gz, psf, psf.gz, sdt, sdt.gz  
sdt.gz									<- Input extension
ifmt_input          23
Input start, end, and increment of file step
{\color{red} 2004 2000 1								<- Input start, end, and increment of file step} 
Write ascii VTK file: zm_y0.2000.vtk
\end{verbatim}
}

\section{Data assemble program ({\tt assemble\_sph})}
\label{section:assemble_sph}
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{images/flow_4}
\end{center}
\caption{Data flow for spectrum data assemble program}
\label{fig:flow_4}
\end{figure}
%
Calypso uses distributed data files for simulations. This program is to generate new spectrum data for restarting with different spatial resolution or parallel configuration. This program organizes new spectral data by using specter indexing data using different domain decomposition. The following files used for data IO. If radial resolution is changed from the original data, the program makes new spectrum data by linear interpolation. If new data have smaller or larger truncation degree, the program fills zero to the new spectrum data or truncates the data to fit the new spatial resolution, respectively. This program can perform with any number of MPI processes, but we recommend to run the program with {\bf one} process or the same number of processes as the number of subdomains for the target configuration which is defined by \verb|num_new_domain_ctl|. Data files for the program are shown In Table \ref{table:assemble_newsph}. The time and number of time step can also be changed by this program. The new time and time step are defined by the parameters in \verb|new_time_step_ctl| block. The step number of the restart data will be \verb|i_step_init_ctl| / \verb|i_step_rst_ctl| in  \verb|new_time_step_ctl|. If \verb|new_time_step_ctl| block is not defined, time and time step informations are carried from the original restart data.

%
\begin{table}[htp]
\caption{List of files for {\tt assemble\_sph} }
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
 extension & Distributed? & I/O \\ \hline
\verb|control_assemble_sph| & Serial & Input \\ \hline
\verb|[sph_prefix].[rj_extension]|  & - & Input \\  \hline
\verb|[new_sph_prefix].[domain#].rj| &  Distributed & Input \\ \hline
\verb|[rst_prefix].[step#].[rst_extension]| & - & Input  \\
\verb|[new_rst_prefix].[step#].[domain#].fst| &  Distributed & Output \\ \hline
\end{tabular}
\end{center}
\label{table:assemble_newsph}
\end{table}
%

\subsection{Format of control file}
Control file consists the following groups. \\
%
Block \verb|assemble_control| \label{href_i:assemble_control} (Top lebel of the block)
\begin{itemize}
\item Block \verb|data_files_def|
	\hyperref[href_t:data_files_def]{(Detail)}
	\begin{itemize}
	\item \hyperref[href_t:num_subdomain_ctl]
			{\tt num\_subdomain\_ctl    [Num\_PE]}
	\item \hyperref[href_t:sph_file_prefix]
			{\tt sph\_file\_prefix      [sph\_prefix]}
	\item \hyperref[href_t:restart_file_prefix]
            {\tt restart\_file\_prefix  [rst\_prefix])}
%
	\item \hyperref[href_t:sph_file_fmt_ctl]
			{\tt sph\_file\_fmt\_ctl    [sph\_format]}
	\item \hyperref[href_t:restart_file_fmt_ctl]
			{\tt restart\_file\_fmt\_ctl    [rst\_format]}
	\end{itemize}
%
\item Block \verb|new_data_files_def|
	\label{href_i:new_data_files_def}
	\hyperref[href_t:new_data_files_def]{(Detail)}
	\begin{itemize}
	\item \hyperref[href_t:num_subdomain_ctl]
			{\tt num\_subdomain\_ctl    [Num\_PE]}
	\item \hyperref[href_t:sph_file_prefix]
			{\tt sph\_file\_prefix      [sph\_prefix]}
	\item \hyperref[href_t:restart_file_prefix]
            {\tt restart\_file\_prefix  [rst\_prefix])}
%
	\item \hyperref[href_t:sph_file_fmt_ctl]
			{\tt sph\_file\_fmt\_ctl    [sph\_format]}
	\item \hyperref[href_t:restart_file_fmt_ctl]
			{\tt restart\_file\_fmt\_ctl    [rst\_format]}
%
	\item \hyperref[href_t:delete_original_data_flag]
			{\tt delete\_original\_data\_flag    [YES or NO]}
	\end{itemize}
%
\item Block \verb|control|
	\begin{itemize}
	\item Block \hyperref[href_t:time_step_ctl]{\tt time\_step\_ctl}
		\begin{itemize} \label{href_i:time_step_ctl2}
		\item \hyperref[href_t:i_step_init_ctl]
			{\tt i\_step\_init\_ctl        [ISTEP\_START]}
		\item \hyperref[href_t:i_step_finish_ctl]
			{\tt i\_step\_finish\_ctl      [ISTEP\_FINISH]}
		\item \hyperref[href_t:i_step_rst_ctl]
			{\tt i\_step\_rst\_ctl         [ISTEP\_RESTART]}
		\end{itemize}
%
	\item  Block \hyperref[href_t:i_step_init_ctl]{\tt new\_time\_step\_ctl}
		\begin{itemize} \label{href_i:new_time_step_ctl}
		\item \hyperref[href_t:i_step_init_ctl_a]
			{\tt i\_step\_init\_ctl        [ISTEP\_START]}
		\item \hyperref[href_t:i_step_rst_ctl_a]
			{\tt i\_step\_rst\_ctl         [ISTEP\_RESTART]}
		\item \hyperref[href_t:time_init_ctl_a]
			{\tt time\_init\_ctl           [INITIAL\_TIME]}
		\end{itemize}
	\end{itemize}
%
\item Block \hyperref[href_t:newrst_magne_ctl]{\tt newrst\_magne\_ctl}
	\begin{itemize} \label{href_i:newrst_magne_ctl}
	\item \hyperref[href_t:magnetic_field_ratio_ctl]
		{\tt magnetic\_field\_ratio\_ctl    [ratio]}
	\end{itemize}
\end{itemize}

\section{Time averaging programs}
These small programs are used to evaluate time average and standard deviation of the time evolution data.
\subsection{Averaging for mean square and power spectrum \\
 ({\tt t\_ave\_sph\_mean\_square})}
This program generate time average and standard deviation of power spectrum data. The program processes one of data files listed in Table \ref{table:time_averages_sprectr}. The number for the first and second interactive input is also listed in Table \ref{table:time_averages_sprectr}. For the third input, the file name excluding \verb|.dat| is required. Start and end time is also required in the last input. If data is end before the end time, the program will finish at the end of file. \verb|t_ave| and \verb|t_sigma| are added at the beginning of the input file name for the time average and standard deviation data file, respectively.
%
\begin{table}[htp]
\caption{List of programs to take time average}
\begin{center} 
\begin{tabular}{|c|c|c|c|}
\hline
 name & First input & Second input \\ \hline \hline
\verb|[vol_pwr_prefix]_s.dat| & 1 & 1 \\ \hline
\verb|[vol_pwr_prefix]_l.dat| & 2 & 1 \\
\verb|[vol_pwr_prefix]_m.dat| & 2 & 1 \\
\verb|[vol_pwr_prefix]_lm.dat| & 2 & 1 \\ \hline
\verb|[layer_pwr_prefix]_s.dat| & 1 & 0  \\ \hline
\verb|[layer_pwr_prefix]_l.dat| & 2 & 0 \\
\verb|[layer_pwr_prefix]_m.dat| & 2 & 0 \\
\verb|[layer_pwr_prefix]_lm.dat| & 2 & 0 \\ \hline
\end{tabular}
\end{center}
\label{table:time_averages_sprectr}
\end{table}
%
\subsection{Averaging for picked harmonics mode data \\
 ({\tt t\_ave\_picked\_sph\_coefs})}
This program generate time average and standard deviation of spherical harmonic coefficients which selected in the file \verb|[picked_sph_prefix].dat|.

In this program, file prefix  \verb|[picked_sph_prefix]| and start and end time are required in the interactive input. If data is end before the end time, the program will finish at the end of file. \verb|t_ave| and \verb|t_sigma| are added at the beginning of the input file name for the time average and standard deviation data file, respectively.
%
\subsection{Averaging for Nusselt number data \\
 ({\tt t\_ave\_nusselt})}
This program generate time average and standard deviation of the Nusselt number in the file \verb|[nusselt_number_prefix].dat|. 

In this program, file prefix  \verb|[nusselt_number_prefix]| and start and end time are required in the interactive input. If data is end before the end time, the program will finish at the end of file. \verb|t_ave| and \verb|t_sigma| are added at the beginning of the input file name for the time average and standard deviation data file, respectively.
%

\section{Module dependency program ({\tt module\_dependency})}
This program is only used to generate Makefile in {\tt work} directory. Most of case, Fortran 90 modules have to compiled prior to be referred by another fortran90 routines. This program is generates dependency lists in Makefile. To use this program, the following limitation is required.
\begin{itemize}
\item One source code has to consist of one module.
\item The module name should be the same as the file name.
\end{itemize}
%
\section{Visualization using field data}
\label{sec:paraview}
The field data is written by XDMF or VTK data format using Cartesian coordinate. In this section we briefly introduce how to display the radial magnetic field using ParaView as an example.
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{images/paraview_open}
\caption{File open window for ParaView}
\label{fig:paraview_load}
\end{center}
\end{figure}
%

After the starting Paraview, the file to be read is chosen in the file menu, and press "apply", button. Then, Paraview load the data from files (see Figure \ref{fig:paraview_load}). 
Because the magnetic field is saved by the Cartesian coordinate, the radial magnetic field is obtained by the calculator tool. The procedure is as following (see Figure \ref{fig:paraview_gen_Br})
%
\begin{enumerate}
\item Push calculator button.
\item Choose "Point Data" in Attribute menu
\item Input data name for radial magnetic field ("B\_r" in  Figure \ref{fig:paraview_gen_Br})
\item Enter the equation to evaluate radial mantic field $B_{r} = \bvec{B} \cdot \bvec{r} / |r|$.
\item Finally, push "Apply" button.
\end{enumerate}
%
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=100mm]{images/paraview_calc}
\caption{File open window for ParaView}
\label{fig:paraview_gen_Br}
\end{center}
\end{figure}
%
After obtaining the radial mantric field, the image in figure \ref{fig:paraview_br} is obtained by using "slice" and  "Contour" tools with appropriate color mapping.
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=100mm]{images/Paraview_Br}
\end{center}
\caption{Visualization of radial magnetic field by Paraview.}
\label{fig:paraview_br}
\end{figure}
%

