\newpage
%

\section{Simulation program ({\tt sph\_mhd})}
\label{section:sph_mhd}
%

The name of the simulation program is {\tt sph\_mhd}. This program requires {\tt control\_MHD} as a Control file. This program performs with the paramer file {\tt control\_MHD}, boundary condition data file \verb|[boundary_data_name]| (optional), and  indexing file for spherical harmonics generated by the preprocessing program {\tt gen\_sph\_grid} (optional).
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{Images/flow_2}
\end{center}
\caption{Data flow for the simulation program.}
\label{fig:flow_2}
\end{figure}
%
Data files for this program are listed in Table \ref{table:sph_mhd}. Indexing data for spherical harmonics which starting with \verb|[sph_prefix]| are obtained by the preprocessing program \verb|gen_sph_grid|. If these indexing data files do not exist, the spherical harmonics indexing data files are also generated by using information in \verb|spherical_shell_ctl| block. The boundary condition data file \verb|[boundary_data_name]| is optionally required if boundary conditions for temperature and composition are not homogenous.
%
\begin{table}[htp]
\caption{List of Inoput/Output files of {\tt sph\_mhd} }
\begin{center} 
\begin{tabular}{|c|c|}
\hline
 name  & I/O \\ \hline \hline
\verb|control_MHD| & Input \\ \hline
\verb|[boundary_data_name]| & Input (opthional) \\ \hline
\verb|[rst_prefix].[step #].[rst_extension]| & Input/Output  \\ \hline
\end{tabular}
\end{center}
\label{table:sph_mhd}
\end{table}
%
\begin{table}[htp]
\caption{List of output files for visualization and data analysis of {\tt sph\_mhd} }
\begin{center} 
\begin{tabular}{|c|}
\hline
 name  \\ \hline \hline
\verb|[vol_pwr_prefix]_s.[dat/dat.gz]|   \\ \hline
\verb|[vol_pwr_prefix]_l.[dat/dat.gz]|   \\
\verb|[vol_pwr_prefix]_m.[dat/dat.gz]|   \\
\verb|[vol_pwr_prefix]_m0.[dat/dat.gz]|   \\
\verb|[vol_pwr_prefix]_lm.[dat/dat.gz]|   \\
\verb|[vol_ave_prefix].[dat/dat.gz]|   \\ \hline
\verb|[layer_pwr_prefix]_s.[dat/dat.gz]|   \\
\verb|[layer_pwr_prefix]_l.[dat/dat.gz]|   \\
\verb|[layer_pwr_prefix]_m.[dat/dat.gz]|   \\
\verb|[layer_pwr_prefix]_m0.[dat/dat.gz]|   \\
\verb|[layer_pwr_prefix]_lm.[dat/dat.gz]|   \\ \hline
\verb|[gauss_coef_prefix].[dat/dat.gz]|     \\
\verb|[picked_sph_prefix].[dat/dat.gz]|     \\ \hline
\verb|[nusselt_number_prefix].[dat/dat.gz]|     \\ \hline
\verb|[dipolarity_file_prefix].[dat/dat.gz]|     \\ \hline
\verb|[dynamo_benchmark_data_ctl].[dat/dat.gz]|     \\ \hline
\verb|[field_on_circle_prefix].[dat/dat.gz]|     \\ \hline
\verb|[spectr_on_circle_prefix].[dat/dat.gz]|     \\ \hline
\verb|[fld_prefix].[step#].[domain#].[extension]|   \\ \hline
\verb|[section_prefix].[step#].[extension]|   \\
\verb|[isosurface_prefix].[step#].[extension]|  \\ \hline
\end{tabular}
\end{center}
\label{table:sph_mhd_out}
\end{table}
%
%
\begin{table}[htp]
\caption{List of optional files to use data by Ver.1.x}
\begin{center} 
\begin{tabular}{|c|c|}
\hline
 name & I/O \\ \hline \hline
\verb|[sph_prefix].[rj_extension]|  & Input / (Output) \\
\verb|[sph_prefix].[rlm_extension]| & Input / (Output) \\
\verb|[sph_prefix].[rtm_extension]| & Input / (Output) \\
\verb|[sph_prefix].[rtp_extension]| & Input / (Output) \\ \hline
\verb|[sph_prefix].[fem_extension]| & (Input / Output) \\ \hline
\end{tabular}
\end{center}
\label{table:sph_mhd_optional}
\end{table}
%

{\color{red} {\bf Caution:} Calypso can save data files into subdirectories where is defined in control files. However, These directories have to prepare before the simulations because Fortran does not have a feature to make a new directory.}

%
\newpage
\subsection{Control file}
Control files for Calypso consists of blocks starting and ending with \verb|begin| and \verb|end|, respectively. Entities with more than one components are defined between \verb|begin array| and \verb|end array| flags. The number of components of an array must be defined at \verb|begin array| line. If blocks to be defined in an external file, the external file name is defined by \verb|file| flag. 

The format of the control file \verb|control_MHD| is described below. The detail of each block is described in section \ref{section:def_control}. You can jump to detailed description by clicking each item. \\
\\
%
Block \verb|MHD_control|  (Top block of the control file)
\label{href_i:MHD_control}
%
\begin{itemize}
\item Block \hyperref[href_t:data_files_def]{\tt data\_files\_def}
	\label{href_i:data_files_def}
%
	\begin{itemize}
	\item \hyperref[href_t:num_subdomain_ctl]
			{\tt num\_subdomain\_ctl    [Num\_PE]}
	\item \hyperref[href_t:num_smp_ctl]
			{\tt num\_smp\_ctl    [Num\_Threads]}
	\item \hyperref[href_t:sph_file_prefix]
			{\tt sph\_file\_prefix    [sph\_prefix]}
	\item \hyperref[href_t:boundary_data_file_name]
		{\tt boundary\_data\_file\_name    [File\_Name]}
%	\item \hyperref[href_t:radial_field_file_name]
%		{\tt radial\_field\_file\_name    [File_Name]}
%
	\item \hyperref[href_t:restart_file_prefix]
		{\tt restart\_file\_prefix    [rst\_prefix]}
	\item \hyperref[href_t:field_file_prefix]
			{\tt field\_file\_prefix    [fld\_prefix]}
%
	\item \hyperref[href_t:sph_file_fmt_ctl]
			{\tt sph\_file\_fmt\_ctl    [sph\_format]}
	\item \hyperref[href_t:restart_file_fmt_ctl]
			{\tt restart\_file\_fmt\_ctl    [rst\_format]}
	\item \hyperref[href_t:field_file_fmt_ctl]
			{\tt field\_file\_fmt\_ctl    [fld\_format]}
	\end{itemize}
%
\item File or Block \hyperref[href_i:spherical_shell_ctl]
			{\tt spherical\_shell\_ctl        [resolution\_control]}  \\
			 (See Section \ref{section:resolution_block})
	\begin{itemize}
	\item Block \hyperref[href_i:FEM_mesh_ctl]
        {\tt FEM\_mesh\_ctl} (See Section \ref{section:resolution_block})
	\item Block \hyperref[href_i:num_domain_ctl]
		{\tt num\_domain\_ctl} (See Section \ref{section:resolution_block})
	\item Block \hyperref[href_i:num_grid_sph]
		{\tt num\_grid\_sph} (See Section \ref{section:resolution_block})
	\end{itemize}
%
\item Block \verb|model|
	\begin{itemize}
	\item Block \hyperref[href_t:phys_values_ctl]{\tt phys\_values\_ctl}
		\begin{itemize} \label{href_i:phys_values_ctl}
		\item Array \hyperref[href_t:nod_value_ctl]
			{\tt nod\_value\_ctl    [Field]  [Viz\_flag]  [Monitor\_flag]}
		\end{itemize}
%
	\item Block \hyperref[href_t:time_evolution_ctl]{\tt time\_evolution\_ctl}
		\begin{itemize} \label{href_i:time_evolution_ctl}
		\item Array \hyperref[href_t:time_evo_ctl]
			{\tt time\_evo\_ctl    [Field]}
		\end{itemize}
%
	\item Block \hyperref[href_t:boundary_condition]{\tt boundary\_condition}
		\begin{itemize} \label{href_i:boundary_condition}
		\item Array \hyperref[href_t:bc_temperature]
            {\tt bc\_temperature       [Group]  [Type]  [Value]}
		\item Array \hyperref[href_t:bc_velocity]
			{\tt bc\_velocity          [Group]  [Type]  [Value]}
		\item Array \hyperref[href_t:bc_composition]
			{\tt bc\_composition       [Group]  [Type]  [Value]}
		\item Array \hyperref[href_t:bc_magnetic_field]
			{\tt bc\_magnetic\_field    [Group]  [Type]  [Value]}
		\end{itemize}
%
	\item Block \hyperref[href_t:forces_define]{\tt forces\_define}
		\begin{itemize} \label{href_i:forces_define}
		\item Array \hyperref[href_t:force_ctl]{\tt force\_ctl    [Force]}
		\end{itemize}
%
	\item Block \hyperref[href_t:dimensionless_ctl]{\tt dimensionless\_ctl}
		\begin{itemize} \label{href_i:dimensionless_ctl}
		\item Array \hyperref[href_t:dimless_ctl]{\tt dimless\_ctl    [Name]  [Value]}
		\end{itemize}
%
	\item Block \hyperref[href_t:coefficients_ctl]{\tt coefficients\_ctl}
		\begin{itemize} \label{href_i:coefficients_ctl}
		\item Block \hyperref[href_t:thermal]{\tt thermal}
			\begin{itemize} \label{href_i:thermal}
			\item Array \hyperref[href_t:coef_4_termal_ctl]
					{\tt coef\_4\_termal\_ctl          [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_t_diffuse_ctl]
					{\tt coef\_4\_t\_diffuse\_ctl      [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_heat_source_ctl]
					{\tt coef\_4\_heat\_source\_ctl    [Name] [Power]}
			\end{itemize}
%
		\item Block \hyperref[href_t:momentum]{\tt momentum}
			\begin{itemize} \label{href_i:momentum}
			\item Array \hyperref[href_t:coef_4_velocity_ctl]
				{\tt coef\_4\_velocity\_ctl          [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_press_ctl]
				{\tt coef\_4\_press\_ctl             [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_v_diffuse_ctl]
                {\tt coef\_4\_v\_diffuse\_ctl         [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_buoyancy_ctl]
				{\tt coef\_4\_buoyancy\_ctl          [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_Coriolis_ctl]
				{\tt coef\_4\_Coriolis\_ctl          [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_Lorentz_ctl]
				{\tt coef\_4\_Lorentz\_ctl           [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_composit_buoyancy_ctl]
				{\tt coef\_4\_composit\_buoyancy\_ctl [Name] [Power]}
			\end{itemize}
%
		\item Block \hyperref[href_t:induction]{\tt induction}
			\begin{itemize} \label{href_i:induction}
			\item Array \hyperref[href_t:coef_4_magnetic_ctl]
				{\tt coef\_4\_magnetic\_ctl   [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_m_diffuse_ctl]
				{\tt coef\_4\_m\_diffuse\_ctl [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_induction_ctl]
				{\tt coef\_4\_induction\_ctl  [Name] [Power]}
			\end{itemize}
%
		\item Block \hyperref[href_t:composition]{\tt composition}
			\begin{itemize} \label{href_i:composition}
			\item Array \hyperref[href_t:coef_4_composition_ctl]
				{\tt coef\_4\_composition\_ctl         [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_c_diffuse_ctl]
				{\tt coef\_4\_c\_diffuse\_ctl          [Name] [Power]}
			\item Array \hyperref[href_t:coef_4_composition_source_ctl]
				{\tt coef\_4\_composition\_source\_ctl [Name] [Power]}
			\end{itemize}
		\end{itemize}
%
%	\item Block \hyperref[href_t:gravity_define]{\tt gravity\_define}
%		\begin{itemize} \label{href_i:gravity_define}
%		\item \verb||
%				\hyperref[href_t:gravity_type_ctl]{\tt gravity\_type\_ctl    [Name]}
%		\end{itemize}
%
%	\item Block \hyperref[href_t:Coriolis_define]{\tt Coriolis_define}
%		\begin{itemize} \label{href_i:Coriolis_define}
%		\item Array \hyperref[href_t:rotation_vec]
%				{\tt rotation\_vec    [Direction] [Value]}
%		\end{itemize}
%
	\item Block \hyperref[href_t:temperature_define]{\tt temperature\_define}
		\begin{itemize} \label{href_i:temperature_define}
		\item \verb||
				\hyperref[href_t:ref_temp_ctl]{\tt ref\_temp\_ctl        [REFERENCE\_TYPE]}
		\item \verb||
				\hyperref[href_t:ref_field_file_name]{\tt ref\_field\_file\_name [File\_Name]}
		\item Block \hyperref[href_t:low_temp_ctl]{\tt low\_temp\_ctl}
			\begin{itemize}
			\item \hyperref[href_t:depth]      {\tt depth        [RADIUS]}
			\item \hyperref[href_t:temperature]{\tt temperature  [TEMPERATURE]}
			\end{itemize}
%
		\item Block \hyperref[href_t:high_temp_ctl]{\tt high\_temp\_ctl}
			\begin{itemize}
			\item \hyperref[href_t:depth]      {\tt depth        [RADIUS]}
			\item \hyperref[href_t:temperature]{\tt temperature  [TEMPERATURE]}
			\end{itemize}
		\end{itemize}
%
	\item Block \hyperref[href_t:composition_define]{\tt tcomposition\_define}
		\begin{itemize} \label{href_i:composition_define}
		\item \verb||
				\hyperref[href_t:ref_comp_ctl]{\tt ref\_comp\_ctl        [REFERENCE\_TYPE]}
		\item \verb||
				\hyperref[href_t:ref_field_file_name]{\tt ref\_field\_file\_name [File\_Name]}
		\item Block \hyperref[href_t:low_comp_ctl]{\tt low\_comp\_ctl}
			\begin{itemize}
			\item \hyperref[href_t:depth]      {\tt depth        [RADIUS]}
			\item \hyperref[href_t:composition]{\tt composition  [COMPOSITION]}
			\end{itemize}
%
		\item Block \hyperref[href_t:high_comp_ctl]{\tt high\_comp\_ctl}
			\begin{itemize}
			\item \hyperref[href_t:depth]      {\tt depth        [RADIUS]}
			\item \hyperref[href_t:composition]{\tt composition  [COMPOSITION]}
			\end{itemize}
		\end{itemize}
	\end{itemize}
%
\item Block \verb|control|
	\begin{itemize}
	\item Block \hyperref[href_t:time_step_ctl]{\tt time\_step\_ctl}
		\begin{itemize} \label{href_i:time_step_ctl}
		\item \hyperref[href_t:elapsed_time_ctl]
			{\tt elapsed\_time\_ctl        [ELAPSED\_TIME]}
		\item \hyperref[href_t:i_step_init_ctl]
			{\tt i\_step\_init\_ctl        [ISTEP\_START]}
		\item \hyperref[href_t:i_step_finish_ctl]
			{\tt i\_step\_finish\_ctl      [ISTEP\_FINISH]}
		\item \hyperref[href_t:i_step_check_ctl]
			{\tt i\_step\_check\_ctl       [ISTEP\_MONITOR]}
		\item \hyperref[href_t:i_step_rst_ctl]
			{\tt i\_step\_rst\_ctl         [ISTEP\_RESTART]}
		\item \hyperref[href_t:i_step_field_ctl]
			{\tt i\_step\_field\_ctl       [ISTEP\_FIELD]}
		\item \hyperref[href_t:i_step_sectioning_ctl]
			{\tt i\_step\_sectioning\_ctl  [ISTEP\_SECTION]}
		\item \hyperref[href_t:i_step_isosurface_ctl]
			{\tt i\_step\_isosurface\_ctl  [ISTEP\_ISOSURFACE]}
		\item \hyperref[href_t:dt_ctl]
			{\tt dt\_ctl                   [DELTA\_TIME]}
		\item \hyperref[href_t:time_init_ctl]
			{\tt time\_init\_ctl           [INITIAL\_TIME]}
		\end{itemize}
%
	\item Block \hyperref[href_t:restart_file_ctl]{\tt restart\_file\_ctl}
		\begin{itemize} \label{href_i:restart_file_ctl}
		\item \hyperref[href_t:rst_ctl]{\tt rst\_ctl      [INITIAL\_TYPE]}
		\end{itemize}
%
	\item Block \verb||
    		\hyperref[href_t:time_loop_ctl]{\tt time\_loop\_ctl}
		\begin{itemize} \label{href_i:time_loop_ctl}
		\item \hyperref[href_t:scheme_ctl]{\tt scheme\_ctl              [EVOLUTION\_SCHEME]}
		\item \hyperref[href_t:coef_imp_v_ctl]{\tt coef\_imp\_v\_ctl    [COEF\_INP\_U]}
		\item \hyperref[href_t:coef_imp_t_ctl]{\tt coef\_imp\_t\_ctl    [COEF\_INP\_T]}
		\item \hyperref[href_t:coef_imp_b_ctl]{\tt coef\_imp\_b\_ctl    [COEF\_INP\_B]}
		\item \hyperref[href_t:coef_imp_c_ctl]{\tt coef\_imp\_c\_ctl    [COEF\_INP\_C]}
		\item \hyperref[href_t:FFT_library_ctl]{\tt FFT\_library\_ctl   [FFT\_Name]}
		\item \hyperref[href_t:Legendre_trans_loop_ctl]
			{\tt Legendre\_trans\_loop\_ctl [Leg\_Loop]}
		\end{itemize}
%
	\end{itemize}
%
\item Block \hyperref[href_t:sph_monitor_ctl]{\tt sph\_monitor\_ctl}
	\begin{itemize} \label{href_i:sph_monitor_ctl}
	\item \hyperref[href_t:volume_average_prefix]
			{\tt volume\_average\_prefix        [vol\_ave\_prefix]}
	\item \hyperref[href_t:volume_pwr_spectr_prefix]
			{\tt volume\_pwr\_spectr\_prefix    [vol\_pwr\_prefix]}
	\item \hyperref[href_t:volume_pwr_spectr_format]
		{\tt volume\_pwr\_spectr\_format    [file\_format]}
	\item \hyperref[href_t:degree_spectra_switch]
		{\tt degree\_spectra\_switch           [ON/OFF]}
	\item \hyperref[href_t:order_spectra_switch]
		{\tt order\_spectra\_switch           [ON/OFF]}
	\item \hyperref[href_t:diff_lm_spectra_switch]
		{\tt diff\_lm\_spectra\_switch           [ON/OFF]}
	\item \hyperref[href_t:axisymmetric_power_switch]
		{\tt axisymmetric\_power\_switch           [ON/OFF]}
%
	\item \hyperref[href_t:nusselt_number_prefix]
			{\tt nusselt\_number\_prefix        [nusselt\_number\_prefix]}
	\item \hyperref[href_t:nusselt_number_format]
			{\tt nusselt\_number\_format    [file\_format]}
%
	\item Array \hyperref[href_t:volume_spectrum_ctl]{\tt volume\_spectrum\_ctl}
		\begin{itemize}
		\item Block \verb|volume_spectrum_ctl|
			\begin{itemize}
			\item \hyperref[href_t:volume_average_prefix]
				{\tt volume\_average\_prefix      [vol\_ave\_prefix]}
			\item \hyperref[href_t:volume_pwr_spectr_prefix]
				{\tt volume\_pwr\_spectr\_prefix  [vol\_pwr\_prefix]}
        	\item \hyperref[href_t:volume_pwr_spectr_format]
		    	{\tt volume\_pwr\_spectr\_format    [file\_format]}
%
			\item \hyperref[href_t:degree_spectra_switch]
				{\tt degree\_spectra\_switch           [ON/OFF]}
			\item \hyperref[href_t:order_spectra_switch]
				{\tt order\_spectra\_switch           [ON/OFF]}
			\item \hyperref[href_t:diff_lm_spectra_switch]
				{\tt diff\_lm\_spectra\_switch           [ON/OFF]}
			\item \hyperref[href_t:axisymmetric_power_switch]
				{\tt axisymmetric\_power\_switch           [ON/OFF]}
%
			\item \hyperref[href_t:inner_radius_ctl]
				{\tt inner\_radius\_ctl           [radius]}
			\item \hyperref[href_t:outer_radius_ctl]
				{\tt outer\_radius\_ctl           [radius]}
			\end{itemize}
		\end{itemize}
%
	\item Block \hyperref[href_t:layered_spectrum_ctl]{\tt layered\_spectrum\_ctl}
		\begin{itemize}
		\item \hyperref[href_t:layered_pwr_spectr_prefix]
				{\tt layered\_pwr\_spectr\_prefix         [layer\_pwr\_prefix]}
	       	\item \hyperref[href_t:layered_pwr_spectr_format]
		    	{\tt volume\_pwr\_spectr\_format    [file\_format]}
%
		\item \hyperref[href_t:degree_spectra_switch]
			{\tt degree\_spectra\_switch           [ON/OFF]}
		\item \hyperref[href_t:order_spectra_switch]
			{\tt order\_spectra\_switch           [ON/OFF]}
		\item \hyperref[href_t:diff_lm_spectra_switch]
			{\tt diff\_lm\_spectra\_switch           [ON/OFF]}
		\item \hyperref[href_t:axisymmetric_power_switch]
			{\tt axisymmetric\_power\_switch           [ON/OFF]}
%
		\item Array \hyperref[href_t:spectr_radius_ctl]
				{\tt spectr\_radius\_ctl [Radius] }
		\item Array \hyperref[href_t:spectr_layer_ctl]
				{\tt spectr\_layer\_ctl [Layer \#] }
		\end{itemize}
%
	\item Block \hyperref[href_t:gauss_coefficient_ctl]{\tt gauss\_coefficient\_ctl}
		\begin{itemize}
		\item \hyperref[href_t:gauss_coefs_prefix]
			{\tt gauss\_coefs\_prefix                [gauss\_coef\_prefix]}
       	\item \hyperref[href_t:gauss_coefs_format]
		    	{\tt gauss\_coefs\_format    [file\_format]}
		\item \hyperref[href_t:gauss_coefs_radius_ctl]
            {\tt gauss\_coefs\_radius\_ctl           [gauss\_coef\_radius]}
			\item Array \hyperref[href_t:pick_gauss_coefs_ctl]
                		{\tt pick\_gauss\_coefs\_ctl  [Degree]   [Order]}
		\item Array \hyperref[href_t:pick_gauss_coef_degree_ctl]
                    {\tt pick\_gauss\_coef\_degree\_ctl  [Degree]}
		\item Array \hyperref[href_t:pick_gauss_coef_order_ctl]
					{\tt pick\_gauss\_coef\_order\_ctl   [Order]}
		\end{itemize}
%
	\item Block \hyperref[href_t:pickup_spectr_ctl]{\tt pickup\_spectr\_ctl}
		\begin{itemize}
		\item \hyperref[href_t:picked_sph_prefix]
			{\tt picked\_sph\_prefix                    [picked\_sph\_prefix]|}
       	\item \hyperref[href_t:picked_sph_format]
		    	{\tt picked\_sph\_format     [file\_format]}
		\item Array \hyperref[href_t:pick_radius_ctl]
					{\tt pick\_radius\_ctl             [Radius]}
		\item Array \hyperref[href_t:pick_layer_ctl]
					{\tt pick\_layer\_ctl               [Layer \#]}
		\item Array \hyperref[href_t:pick_sph_spectr_ctl]
					{\tt pick\_sph\_spectr\_ctl         [Degree]  [Order]}
		\item Array \hyperref[href_t:pick_sph_degree_ctl]
					{\tt pick\_sph\_degree\_ctl         [Degree]}
		\item Array \hyperref[href_t:pick_sph_order_ctl]
					{\tt pick\_sph\_order\_ctl          [Order]}
		\end{itemize}
%
	\item Block \hyperref[href_t:sph_dipolarity_ctl]{\tt sph\_dipolarity\_ctl}
		\begin{itemize}
		\item \hyperref[href_t:dipolarity_file_prefix]
			{\tt dipolarity\_file\_prefix                    [dipolarity\_file\_prefix]|}
       	\item \hyperref[href_t:dipolarity_file_format]
		    	{\tt dipolarity\_file\_format     [file\_format]}
		\item Array \hyperref[href_t:dipolarity_truncation_ctl]
					{\tt dipolarity\_truncation\_ctl               [Degree]}
		\end{itemize}
%
	\item Block \hyperref[href_t:dynamo_benchmark_data_ctl]
				{\tt dynamo\_benchmark\_data\_ctl}
		\begin{itemize}
			\item \hyperref[href_t:dynamo_benchmark_file_prefix]
					{\tt dynamo\_benchmark\_file\_prefix   [File\_Prefix]}
					\label{href_i:dynamo_benchmark_file_prefix}
			\item \hyperref[href_t:dynamo_benchmark_file_format]
					{\tt dynamo\_benchmark\_file\_format   [ASCII or gzip]}
					\label{href_i:dynamo_benchmark_file_format}
			\item \hyperref[href_t:nphi_mid_eq_ctl]
					{\tt nphi\_mid\_eq\_ctl   [Nphi\_mid\_equator]}
					\label{href_i:nphi_mid_eq_ctl}
		\end{itemize}
%
	\item Array \hyperref[href_t:fields_on_circle_ctl]
				{\tt fields\_on\_circle\_ctl}
		\begin{itemize}
		\item Block {\tt fields\_on\_circle\_ctl}
			\begin{itemize}
				\item \hyperref[href_t:field_on_circle_prefix]
						{\tt field\_on\_circle\_prefix   [File\_Prefix]}
						\label{href_i:field_on_circle_prefix}
				\item \hyperref[href_t:spectr_on_circle_prefix]
						{\tt spectr\_on\_circle\_prefix   [File\_Prefix]}
						\label{href_i:spectr_on_circle_prefix}
				\item \hyperref[href_t:field_on_circle_format]
						{\tt field\_on\_circle\_format   [ASCII or gzip]}
						\label{href_i:field_on_circle_format}
				\item \hyperref[href_t:pick_circle_coord_ctl]
						{\tt pick\_circle\_coord\_ctl   [Coordinate]}
						\label{href_i:pick_circle_coord_ctl}
				\item \hyperref[href_t:nphi_mid_eq_ctl]
						{\tt nphi\_mid\_eq\_ctl   [Nphi\_mid\_equator]}
						\label{href_i:nphi_mid_eq_ctl}
				\item \hyperref[href_t:pick_cylindrical_radius_ctl]
						{\tt pick\_cylindrical\_radius\_ctl   [S]}
						\label{href_i:pick_cylindrical_radius_ctl}
				\item \hyperref[href_t:pick_vertical_position_ctl]
						{\tt pick\_vertical\_position\_ctl    [Z]}
						\label{href_i:pick_vertical_position_ctl}
			\end{itemize}
		\end{itemize}
	\end{itemize}
%
%
\item Block \hyperref[href_t:visual_control]{\tt visual\_control}
    \begin{itemize} \label{href_i:visual_control}
	\item \hyperref[href_t:i_step_sectioning_ctl]
        {\tt i\_step\_sectioning\_ctl  [ISTEP\_SECTION]}
    \item Array \hyperref[href_t:cross_section_ctl]{\tt cross\_section\_ctl}
		\begin{itemize}
        \item File or Block {\tt cross\_section\_ctl} \\
                            {\tt [section\_control\_file]} \\
								(See section \ref{section:section_control})
		\end{itemize}
%
    \item \hyperref[href_t:i_step_isosurface_ctl]
		{\tt i\_step\_isosurface\_ctl  [ISTEP\_ISOSURFACE]}
    \item Array \hyperref[href_t:isosurface_ctl]{\tt isosurface\_ctl}
		\begin{itemize}
		\item File or Block {\tt isosurface\_ctl} \\
                            {\tt [isosurface\_control\_file]} \\
								(See section \ref{section:isosurface_control})
		\end{itemize}
    \end{itemize}
%
\item Block \hyperref[href_t:dynamo_vizs_control]{\tt dynamo\_vizs\_control}
	\begin{itemize} \label{href_i:dynamo_vizs_control}
		\item File or Block \hyperref[href_t:zonal_mean_section_ctl]
							{\tt zonal\_mean\_section\_ctl} \\
							{\tt [zonal\_mean\_section\_control\_file]} \\
								(See section \ref{section:section_control})
		\item File or Block \hyperref[href_t:zonal_RMS_section_ctl]
							{\tt zonal\_RMS\_section\_ctl} \\
                            {\tt [zonal\_RMS\_section\_control\_file]} \\
                                (See section \ref{section:section_control})
%
		\item Block \hyperref[href_t:crustal_filtering_ctl]{\tt crustal\_filtering\_ctl}
			\begin{itemize}
				\item \hyperref[href_t:crustal_filtering_ctl]
						{\tt truncation\_degree\_ctl          [Degree]}
			\end{itemize}
	\end{itemize}
\end{itemize}
%
%
%
\subsubsection{Spatial resolution definition block}
\label{section:resolution_block}

Geometry of spherical shell, spatial resolution, and parallelization is defined in the block named \verb|spherical_shell_ctl|. The \verb|spherical_shell_ctl| block can be included into the file {\tt control\_MHD} or saved into another file.  if the \verb|spherical_shell_ctl| block in the independent file {\tt [resolution\_control]}, the file name is defined by
%
\begin{itemize}
\item {\tt   file    spherical\_shell\_ctl        [resolution\_control]})
\end{itemize}
The \verb|spherical_shell_ctl| block consists of the following parameters
%
\verb|spherical_shell_ctl|
\label{href_i:spherical_shell_ctl}
\\
\\
%
Block \hyperref[href_t:spherical_shell_ctl]{\tt spherical\_shell\_ctl}
%
		\begin{itemize}
		\item (Block \hyperref[href_t:FEM_mesh_ctl]{\tt FEM\_mesh\_ctl})
		\begin{itemize} \label{href_i:FEM_mesh_ctl}
		\item (\hyperref[href_t:FEM_mesh_output_switch]{\tt FEM\_mesh\_output\_switch [ON or OFF]})
		\end{itemize}
%
		\item Block \hyperref[href_t:num_domain_ctl]{\tt num\_domain\_ctl}
			\begin{itemize} \label{href_i:num_domain_ctl}
			\item \hyperref[href_t:ordering_set_ctl]{\tt ordering\_set\_ctl [ORDERING\_SET]}

			\item \hyperref[href_t:num_radial_domain_ctl]{\tt num\_radial\_domain\_ctl [Ndomain]}
			\item \hyperref[href_t:num_horizontal_domain_ctl]{\tt num\_horizontal\_domain\_ctl [Ndomain]}
%
            		\item {\color{magenta} Array \hyperref[href_t:num_domain_sph_grid]
				{\tt num\_domain\_sph\_grid    [Direction]    [Ndomain]} \\
				(Depricated)}
			\item {\color{magenta} Array \hyperref[href_t:num_domain_legendre]
				{\tt num\_domain\_legendre    [Direction]    [Ndomain]} \\
				(Depricated)}
			\item {\color{magenta} Array \hyperref[href_t:num_domain_spectr]
				{\tt num\_domain\_spectr      [Direction]    [Ndomain]} \\
				(Depricated)}
			\end{itemize}
%
		\item Block \hyperref[href_t:num_grid_sph]{\tt num\_grid\_sph}
			\begin{itemize} \label{href_i:num_grid_sph}
	        \item \hyperref[href_t:truncation_level_ctl]{\tt truncation\_level\_ctl	[Lmax]}
			\item \hyperref[href_t:ngrid_meridonal_ctl]{\tt ngrid\_meridonal\_ctl [Ntheta]}
			\item \hyperref[href_t:ngrid_zonal_ctl]{\tt ngrid\_zonal\_ctl [Nphi]}
%
			\item \hyperref[href_t:radial_grid_type_ctl]{\tt radial\_grid\_type\_ctl} \\
				\verb|[explicit, Chebyshev, or equi_distance]| \label{href_i:radial_grid_type_ctl}
%
			\item \hyperref[href_t:num_fluid_grid_ctl]{\tt num\_fluid\_grid\_ctl  [Nr\_shell]}
			\item \hyperref[href_t:fluid_core_size_ctl]{\tt fluid\_core\_size\_ctl  [Length]}
			\item \hyperref[href_t:ICB_to_CMB_ratio_ctl]{\tt ICB\_to\_CMB\_ratio\_ctl  [R\_ratio]}
			\item \hyperref[href_t:Min_radius_ctl]{\tt Min\_radius\_ctl  [Rmin]}    
				\label{href_i:Min_radius_ctl}
			\item \hyperref[href_t:Max_radius_ctl]{\tt Max\_radius\_ctl  [Rmax]}    
				\label{href_i:Max_radius_ctl}
%
\\
			\item Array \hyperref[href_t:r_layer]{\tt r\_layer  [Layer \#]  [Radius]}    
%
			\item Array \hyperref[href_t:boundaries_ctl]{\tt boundaries\_ctl  [Boundary\_name]  [Layer \#]}    
			\end{itemize}
		\end{itemize}

If \verb|num_radial_domain_ctl| and \verb|num_horizontal_domain_ctl| are defined, the following arrays \verb|num_domain_sph_grid|, \verb|num_domain_legendre|, and \verb|num_domain_spectr| are not necessary. \\
(see \hyperref[href_t:gen_w_innercore]{example} \verb|spherical_shell/with_inner_core|)

The external file for resoultion and parallelization information \verb|[resolution_control]| needs the following contorl blocks:
%
	\begin{itemize}
	\item Block \hyperref[href_i:spherical_shell_ctl]{\tt spherical\_shell\_ctl}
		\begin{itemize}
		\item Block \hyperref[href_i:FEM_mesh_ctl]{\tt FEM\_mesh\_ctl}
		\item Block \hyperref[href_i:num_domain_ctl]{\tt num\_domain\_ctl}
		\item Block \hyperref[href_i:num_grid_sph]{\tt num\_grid\_sph}
		\end{itemize}
	\end{itemize}
%
%
Calypso obtains resolution and parallelization information in the following order:
\begin{description}
\item[Step 1:] If spherical harmonics indexing files {\tt  [sph\_prefix]} defined by
\hyperref[href_t:sph_file_prefix]{\tt sph\_file\_prefix    [sph\_prefix]}  are exist, read these files and go to simulation.
\item[Step 2:] If files  {\tt  [sph\_prefix]} does not exist, construct resolution and parallelization information from the parameters in \verb|spherical_shell_ctl| block.
\item[Step 3:] If the parameter \hyperref[href_t:sph_file_prefix]{\tt sph\_file\_prefix    [sph\_prefix]}  is defined, the spherical harmonics indexing files {\tt  [sph\_prefix]} are written (not necessary). 
\end{description}
%
Various data format can be chosen for the spherical harmonic indexing files  {\tt  [sph\_prefix]} (see Section \ref{section:gen_sph_grid}).
%
\subsubsection{Position of radial grid}
The preprocessing program sets the radial grid spacing, either by a list in the control file or by setting an equidistant grid or Chebyshev collocation points.

In equidistance grid, radial grids are defined by
%
\begin{eqnarray}
r(k) & = & r_{i} + \left(r_{o}-r_{i} \right) \frac{k-k_{ICB}}{N},
\nonumber
\end{eqnarray}
%
where, $k_{ICB}$ is the grid points number at ICB. The radial grid set from the closest points of minimum radius defined by \hyperref[href_i:Min_radius_ctl]{\tt [Min\_radius\_ctl]} in control file to the closest points of the maximum radius defined by \hyperref[href_i:Max_radius_ctl]{\tt [Max\_radius\_ctl]} in control file, and radial grid number for the innermost points is set to $k = 1$.

In Chebyshev collocation points, radial grids in the fluid shell are defined by
%
\begin{eqnarray}
r(k) & = & r_{i} + \frac{\left(r_{o}-r_{i} \right)}{2} \left[ \frac{1}{2} - \cos \left(\pi \frac{ k-k_{ICB}}{N} \right) \right],
\nonumber
\end{eqnarray}
%
For the inner core ($r<r_{i}$), grid points is defined by
%
\begin{eqnarray}
r(k) & = & r_{i} - \frac{\left(r_{o}-r_{i} \right)}{2} \left[ \frac{1}{2} - \cos \left(\pi \frac{ k-k_{ICB}}{N} \right) \right],
\nonumber
\end{eqnarray}
%
and, grid points in the external of the shell ($r>r_{o}$) is defined by
%
\begin{eqnarray}
r(k) & = & r_{o} + \frac{\left(r_{o}-r_{i} \right)}{2} \left[ \frac{1}{2} - \cos \left(\pi \frac{ k-k_{CMB}}{N} \right) \right],
\nonumber
\end{eqnarray}
%
where, $k_{CMB}$ is the grid point number at CMB.

\subsubsection{How to define spatial resolution and parallelization?}
  Calypso uses spherical harmonics expansion method and in horizontal discretization and finite difference methods in the radial direction. In the spherical harmonics expansion methods, nonlinear terms are solved in the grid space while time integration and diffusion terms are solved in the spectrum space. We need to set truncation degree $l_{max}$ of the spherical harmonics and number of grids in the three direction $(N_{r}, N_{\theta}, N_{\phi})$ in the preprocessing program. The following condition is required (or recommended) for $l_{max}$ and $(N_{r}, N_{\theta}, N_{\phi})$. $l_{max}$ is defined by \verb|truncation_level_ctl|, and $N_{r}$ for the fluid shell (outer core) is defined by  \verb|num_fluid_grid_ctl|.  $N_{\theta}$ and $N_{\phi}$ is defined by \verb|ngrid_meridonal_ctl| and \verb|ngrid_zonal_ctl|, respectively.
%
\begin{itemize}
\item $N_{\phi} = 2 N_{\theta}$.
\item $N_{\theta}$ must be more than $l_{max}+1$, but
\item To eliminate aliasing in the spherical transform, $N_{\theta} \ge 1.5 \left( l_{max}+1 \right)$ is highly recommended.
\item $N_{\phi}$ should consists of products among power of 2, power of 3, and power of 5.
\end{itemize}
%
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{Images/parallelize}
\end{center}
\caption{Parallelization and data communication in Calypso in the case using 9 (3x3) processors. Data are decomposed in radial and meridional direction for nonlinear term evaluations, decomposed in radial and harmonic order for Legendre transform, and decomposed in spherical harmonics for linear calculations.}
\label{fig:parallelization}
\end{figure}
%
Calypso is parallelized 2-dimensionally and direction of the parallelization is changed in the operations in the spherical transform (See Figure \ref{fig:parallelization}). Two dimensional parallelization delivers many parallelize configuration. Here is the approach  how to find the best configuration:
%
\begin{itemize}
\item Maximum parallelization level in horizontal direction is $\left( l_{max} + 1 \right)  /2$,  and $N_{r}+1$ is the maximum level in radial direction.
\item Decompose number of radial points $N_{r}+1$ and truncation degree $\left( l_{max} + 1 \right) / 2 $ into prime numbers.
\item Decide number of MPI processes from the prime numbers.
\item Choose the number of decomposition in the radial and horizontal direction as close as possible.
\end{itemize}
% 
Here is an example for the case with $(N_{r}, l_{max}) = (89, 95)$. The maximum number of parallelization is $90 \times 48  = 4320$ processes.  $N_{r}+1$ and $\left( l_{max} + 1 \right)  /2$ can be decomposed into $90 = 2 \times 3^2 \times 5$ and $48 = 2^4 \times 3 $. Now, if 160 processes run is intended, $160 = 10 \times 16$ is the closest number of decompositions. Comparing with the prime numbers of the spatial resolution, radial and horizontal decomposition will be 10 and 16, respectively.

\subsubsection{Radial grid data}
The program generates radius of each layer in \verb|radial_info.dat| if \verb|radial_grid_type_ctl| is set to \verb|Chebyshev| or \verb|equi_distance|. This file consists of blocks \verb|array r_layer| and \verb|array boundaries_ctl| for control file. This data may be useful if you want to modify radial grid spacing by yourself.

\subsubsection{Thermal and compositional boundary condition data file}\label{sec:boundary_file}
Thermal and compositional heterogeneity at boundaries are defined by a external file named  \verb|[boundary_data_name]|. In this file, temperature, composition, heat flux, or compositional flux at ICB or CMB can be defined by spherical harmonics coefficients. To use boundary conditions in \verb|[boundary_data_name]|, file name is defined by \verb|boundary_data_file_name| column in control file, and boundary condition type \verb|[type]| is set to \verb|fixed_file| or \verb|fixed_flux_file| in \verb|bc_temperature| or \verb|bc_composition| column. By setting \verb|fixed_file| or \verb|fixed_flux_file| in control file, boundary conditions are copied from the file \verb|[boundary_data_name]|.

An example of the boundary condition file is shown in Figure \ref{fig:boundary_file}. As for the control file, a line starting from '\verb|#|' or '\verb|!|' is recognized as a comment line. In \verb|[boundary_data_name]|, boundary condition data is defined as following:
%
\begin{enumerate}
\item  Number of total boundary conditions to be defined in this file.
\item  Field name to define the first boundary condition
\item  Place to define the first boundary condition (\verb|ICB| or \verb|CMB|)
\item  Number of spherical harmonics modes for each boundary condition
\item  Spectrum data for the boundary conditions (degree $l$, order $m$, and harmonics coefficients)
\item  After finishing the list of spectrum data return to Step 2 for the next boundary condition
\end{enumerate}
%
If harmonics coefficients of the boundary conditions are not listed in item 5, 0.0 is automatically applied for the harmonics coefficients of the boundary conditions. So, only non-zero components need to be listed in the boundary condition file. Lines starting from "\#" or "!" are ignored as comment lines.
%
\begin{figure}[htbp]
\begin{center}
{\small
\begin{verbatim}
#
#  number of boundary conditions
      4
#
#   boundary condition data list
#
#    Fixed temperature at ICB
temperature
ICB
    3
  0  0   1.0E+00
  1  1   2.0E-01
  2  2   3.0E-01
#
#    Fixed heat flux at CMB
heat_flux
CMB
   2
  0  0    -0.9E+0
  1  -1    5.0E-1
#
#    Fixed composition flux at ICB
composite_flux
ICB
   2
  0  0    0.0E+00
  2  0   -2.5E-01
#
#    Fixed composition at CMB
composition
CMB
   2
  0   0   1.0E+00
  2  -2   5.0E-01
\end{verbatim}
}
\end{center}
\caption{An example of boundary condition file.}
\label{fig:boundary_file}
\end{figure}
%
%
\subsubsection{Radial stationary field file}\label{sec:radial_field_file}
Horizontally homogeneous heat and light element source/sink can be defined by the text file defined by  \hyperref[href_t:radial_field_file_name]{\tt [radial\_field\_file\_name]}. If the radial field data file is read, the heat and composition source term in the restart data are overwritten. The data in the file consist of the radius and fields data. The read data are interpolated into the each grids points in the program. If there are more than  one field data, the radial grids in the data file has to be shared for the data. An example of the radial data file is shown in Figure \ref{fig:radial_field_file}. Lines starting from "\#" or "!" are ignored as comment lines. Calypso ignore the field in data file if this field is not used. 
%
\begin{figure}[htbp]
\begin{center}
{\small
\begin{verbatim}
#  domain ID
               0
#  time step number
               0
#  time, Delta t
   0.000000000000000E+000   0.000000000000000E+000
#  Number of grids, fields, and component
    7    3
    1    1    1
radius
   0.000000000000000E+000
   5.384615384615384E-001
   5.440461253489739E-001
   5.440461253489742E-001
   1.488945972412747E+000
   1.488945972412750E+000
   1.538461538461538E+000
heat_source
   0.000000000000000E+000
   0.000000000000000E+000
   0.000000000000000E+000
   0.000000000000000E+000
  -1.000000000000000E+001
  -1.000000000000000E+001
composition_source
   1.000000000000000E+000
   1.000000000000000E+000
   1.000000000000000E+000
   0.000000000000000E+001
   0.000000000000000E+001
   0.000000000000000E+000
   0.000000000000000E+000
\end{verbatim}
}
\end{center}
\caption{An example of boundary condition file.}
\label{fig:radial_field_file}
\end{figure}
%
\subsubsection{Reference fields output file}\label{sec:ref_field_output}
Calypso can solve the heat and composition equation using the reference and perturbation of the temperature and composition when the scalar satisfies the conservation.
When reference field for is used, reference temperature, radial temperature gradient, heat source, composition, radial gradient of composition, and composition source is written in the ifle {\tt reference\_fields.dat}. This file has the same format as the input radial stationary field file  \hyperref[href_t:radial_field_file_name]{\tt [radial\_field\_file\_name]}. This file is useful to figure out the diffusive temperature and composition profile when \hyperref[href_t:ref_temp_ctl]{\tt [ref\_temp\_ctl]} or \hyperref[href_t:ref_comp_ctl]{\tt [ref\_comp\_ctl]} is set to {\tt numerical\_solution}. 
%
\begin{eqnarray}
 0 = \nabla^{2} T_{0} + q_{0},
\nonumber
\end{eqnarray}
%
where $q_{0}$ is the heat source/sink as a function of radius. Simple examples to evaluate the reference field is in {\tt examples/get\_reference\_1} and {\tt examples/get\_reference\_2} directory.

({\color{red} Caution}) When fixed boundary condition is not set for the inner nor outer boundary, it is almost impossible to solve the diffusive profile numerically. Consequently, the diffusive profile is evaluated with applying the fixed boundary condition $T = 0$ at the outer boundary. 
%
%
\subsection{Spectrum data for restarting}
Spectrum data is used for restarting data and generating field data by Data transform program \verb|sph_snapshot|, \verb|sph_zm_snapshot|, or \verb|sph_dynamobench|. This file is saved for each subdomain (MPI processes), then \verb|[step #]| and \verb|[domain #]| are added in the file name. The \verb|[step #]| is calculated by \verb|time step| / \verb|[ISTEP_RESTART]|. Data format is defined by \verb|[restart_file_fmt_ctl]| as shown in Table \ref{table:restart_format}.
%
\begin{table}[htp]
\caption{data format flag {[\tt restart\_file\_fmt\_ctl]} and extensions for the restart file. An example of data size and output time is also listed.}
\begin{center} 
\begin{tabular}{|c|c|c|c|c|}
\hline
File format & \verb|[sph_file_fmt_ctl]|  & \verb|extension| & size (MByte) & time (sec)  \\ \hline \hline
              &  \verb|ascii| & \verb|[#].fld|  & 1,286 & 7.10 \\
Parallel  &  \verb|binary| & \verb|[#].flb|  & 410 & 2.36 \\
              &  \verb|gzip| &  \verb|[#].fld.gz| & 418 &  4.65 \\
              &  \verb|bin_gz| &\verb|[#].flb.gz| & 336 &  2.84 \\ \hline
              & \verb|merged|  &  \verb|.fld| & 1,312 & 50.2 \\
Merged  &  \verb|merged_bin| &  \verb|.flb| & 413 &  2.34 \\
              &  \verb|merged_gz| &  \verb|.fld.gz| & 455 & 8.60 \\
              &  \verb|merged_bin_gz| &  \verb|.flb.gz| & 340 & 3.57 \\ \hline
\end{tabular}
\end{center}
\label{table:restart_format}
\end{table}
%

\subsection{Field data for visualization}
\label{sec:VTK}
Field data is used for the visualization processes. Field data are written with XDMF format (\url{http://www.xdmf.org/index.php/Main_Page}), merged VTK, or distributed VTK format (\url{http://www.vtk.org/VTK/img/file-formats.pdf}). The output data format is defined by \verb|fld_format|. Visualization applications which we checked are listed in Table \ref{table:Viz_app}. Because the field data is written by using Cartesian coordinate $(x,y,z)$ system, coordinate conversion is required to plot vector field in spherical coordinate $(r, \theta, \phi)$ or cylindrical coordinate $(s,\phi, z)$. We will introduce a example of visualization process using ParaView in Section \ref{sec:paraview}. Field data also output merged ASCII or binary format including compression using zlib. These original formats have smaller file size than VTK format because of excluding grid information. Program \hyperref[sec:field_to_VTK]{\tt field\_to\_VTK} generates VTK file from FEM mesh data and field data.
%
\begin{table}[htp]
\caption{Checked visualization application}
\label{table:Viz_app}
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
Control flag & \verb|fld_format| & Application \\ \hline \hline
\verb|VTK| & Distributed VTK & ParaView \\ \hline
\verb|single_VTK| & Merged VTK & ParaView, VisIt, or Mayavi \\ \hline
\verb|VTK_gzip| & Compressed Distributed VTK & ParaView \\
 & & after expanding by {\tt gzip} \\ \hline
\verb|single_VTK_gz| & Compressed Merged VTK & ParaView, VisIt or Mayavi \\
 & &  after expanding by {\tt gzip} \\ \hline
\verb|single_HDF5| & XDMF   & ParaView, VisIt   \\ \hline
\verb|ascii| & Distributed ASCII & - \\
\verb|binary| & Distributed binary & - \\
\verb|gzip| & Distributed compressed ASCII & - \\
\verb|bin_gz| & Distributed compressed binary & - \\
\verb|merged| & Merged ASCII & - \\
\verb|merged_bin| & Merged binary & - \\
\verb|merged_gzip| & Merged compressed ASCII & - \\
\verb|merged_bin_gz| & Merged compressed binary & - \\ \hline
\end{tabular}
\label{table:fld_to_vtk}
\end{center}
More informations about ParaView is in \url{https://www.paraview.org}. \\
More informations about VisIt is in \url{https://wci.llnl.gov/codes/visit/}. \\
More informations about Mayavi is in \url{http://mayavi.sourceforge.net/}. \\
\end{table}
%

\paragraph{Distributed VTK data}
Distributed VTK data have the following advantage and disadvantages to use:
%
\begin{itemize}
\item Advantage
\begin{itemize} 
\item Faster output
\item No external library is required
\end{itemize}
\item Disadvantage
\begin{itemize} 
\item Many data files are generated
\item Total data file size is large
\item Only ParaView supports this format
\end{itemize}
\end{itemize}
%
Distributed VTK data consist files listed in Table \ref{table:parallel_vtk}. For ParaView, all subdomain data is read by choosing \verb|[fld_prefix].[step#].pvtk| in file menu.
%
\begin{table}[htp]
\caption{List of written files for distributed VTK format}
\begin{center} 
\begin{tabular}{|c|c|}
\hline
 name &  \\ \hline \hline
\verb|[fld_prefix].[step#].[domain#].vtk|  & VTK data for each subdomain  \\ \hline
\verb|[fld_prefix].[step#].pvtk| & Subdomain file list for Paraview  \\ \hline
\end{tabular}
\end{center}
\label{table:parallel_vtk}
\end{table}
%

\paragraph{Merged VTK data}
Merged VTK data have the following advantage and disadvantages to use:
%
\begin{itemize}
\item Advantage
\begin{itemize} 
\item Merged field data is generated
\item No external library is required
\item Many applications support VTK format
\end{itemize}
\item Disadvantage
\begin{itemize} 
\item Very slow to output
\item Total data file size is large
\end{itemize}
\end{itemize}
%
Merged VTK data generate files listed in Table \ref{table:Merged_vtk}. 
%
\begin{table}[htp]
\caption{List of written files for merged VTK format}
\begin{center} 
\begin{tabular}{|c|c|}
\hline
 name &  \\ \hline \hline
\verb|[fld_prefix].[step#].vtk|  & Merged VTK data  \\ \hline
\end{tabular}
\end{center}
\label{table:Merged_vtk}
\end{table}
%

\paragraph{Merged XDMF data}
Merged XDMF data have the following advantage and disadvantages to use:
%
\begin{itemize}
\item Advantage
\begin{itemize} 
\item Fastest output
\item Merged field data is generated
\item File size is smaller than the VTK formats
\end{itemize}
\item Disadvantage
\begin{itemize} 
\item Parallel HDF5 library should be required to use
\end{itemize}
\end{itemize}
%
Merged XDMF data generate files listed in Table \ref{table:XDMF}. For ParaView, all subdomain data is read by choosing \verb|[fld_prefix].solution.xdmf| in file menu.
%
\begin{table}[htp]
\caption{List of written files for XDMF format}
\begin{center} 
\begin{tabular}{|c|c|}
\hline
 name &  \\ \hline \hline
\verb|[fld_prefix].mesh.h5|  & HDF5 file for geometry data \\ \hline
\verb|[fld_prefix].[step#].h5|  &HDF5 file for field data   \\ \hline
\verb|[fld_prefix].solution.xdmf|  & HDF5 file lists to be read  \\ \hline
\end{tabular}
\end{center}
\label{table:XDMF}
\end{table}
%
\paragraph{Calypso field data}
Calypso field data is based on the spectr data for restarting. The data is simply replaced from spherical harmonics coefficients to each component of field data in the cartesian coordinate. The file format flag \verb|[field_file_fmt_ctl]| and corresponding extensiton are showw in Table \ref{table:field_format}.
%
%
\begin{table}[htp]
\caption{Data format flag {[\tt field\_file\_fmt\_ctl]} and extensions for the field file. An example of data size and output time is also listed.}
\begin{center} 
\begin{tabular}{|c|c|c|c|c|}
\hline
File format & \verb|[field_file_fmt_ctl]|  & \verb|extension| & size (GByte) & time (sec)  \\ \hline \hline
              &  \verb|ascii| & \verb|[#].fld|  & 9.31 & 61.1 \\
              &  \verb|binary| & \verb|[#].flb|  & 2.93 & 39.4  \\
Parallel  &  \verb|gzip| &  \verb|[#].fld.gz| & 3.25 &  40.6 \\
              &  \verb|bin_gz| &\verb|[#].flb.gz| & 2.78 &  39.6\\
              &  \verb|VTK| & \verb|[#].vtk|  & 12.4 & 1030.5 \\
              &  \verb|VTK_gz| & \verb|[#].vtk.gz|  & 3.36 & 40.8 \\ \hline
              & \verb|merged|  &  \verb|.fld| & 9.53 & 39.1 \\
 Merged &  \verb|merged_bin| &  \verb|.flb| & 3.58 & 41.7  \\
              &  \verb|merged_gz| &  \verb|.fld.gz| & 2.99 &  39.4  \\
              &  \verb|merged_bin_gz| &  \verb|.flb.gz| & 2.84 &  39.2 \\
              &  \verb|merged_VTK| & \verb|.vtk|  & 11.8 & 39.3 \\
              &  \verb|merged_VTK_gz| & \verb|.vtk.gz|  & 3.13 & 39.0 \\  \hline
\end{tabular}
\end{center}
\label{table:field_format}
\end{table}
%

%
\subsection{Cross section data (Parallel Surfacing module)}
\label{section:PSF}
Calypso can output cross section data for visualization with finer time increment than the whole domain data. The cross section data consist of triangle patches with VTK format, then data can be visualized by Paraview like as the whole field data. This cross sectioning module can output arbitrary quadrature surface, but plane, sphere, and cylindrical section would be useful for the geodynamo simulations.

To output cross sectioning, increment of the surface output data should be defined by \verb|i_step_sectioning_ctl| in \verb|time_step_ctl| block. And, array block \\ \verb|cross_section_ctl| in \verb|visual_control| section is required to define cross sections. Each \verb|cross_section_ctl| block defines one cross section. Each cross section can also define by an external file by specifying external file name with \verb|file| label.
%
The sections shown in Table \ref{table:section_list} are supported in the sectioning module. These surfaces are defined in the Cartesian coordinate.
\begin{table}[htp]
\caption{Supported cross sections}
\begin{center}
\begin{tabular}{|c|c|}
\hline
Surface type & equation \\ \hline
Quadrature surface 
 & $a x^2 + b y^2 + c z^2 + d y z + e z x + f x y + g x + h y + j z + k = 0$ \\
Plane surface 
& $a \left(x-x_{0} \right) + b \left(y-y_{0} \right) + c \left(z-z_{0} \right) = 0$ \\
 Sphere 
& $\left(x-x_{0} \right)^2 + \left(y-y_{0} \right)^2 + \left(z-z_{0} \right)^2 = r^2$  \\
 Ellipsoid 
& $\displaystyle{ \left(\frac{x-x_{0}}{a} \right)^2 + \left( \frac{y-y_{0}}{b} \right)^2 + \left( \frac{z-z_{0}}{c} \right)^2} = 1$ \\
\hline
\end{tabular}
\end{center}
\label{table:section_list}
\end{table}
%
The easiest approarch is using sections defined by quadrature function with ten coefficients from $a$ to $k$ in the control array \verb|coefs_ctl|.

A plane surface is defined by a normal vector $(a, b, c)$ and one point including the surface $(x_{0}, y_{0}, z_{0})$ in arrays \verb|normal_vector| and \verb|center_position|, respectively.

A sphere surface is defined by the position of the center $(x_{0}, y_{0}, z_{0})$ and radius $r$ in array \verb|center_position| and \verb|radius|, respectively.

An Ellipsoid surface is defined the position of the center $(x_{0}, y_{0}, z_{0})$ and length of the each axis $(a, b, c)$ in arrays  \verb|center_position| and \verb|axial_length|, respectively. If one component of the \verb|axial_length| is set to 0, surfacing module generate a Ellipsoidal tube along with the axis where \verb|axial_length| is set to 0.

Area for visualization can be defined by array \verb|chosen_ele_grp_ctl| by choosing \verb|outer_core|, \verb|inner_core|, and \verb|all|. Fields to display is defined in array \verb|output_field|. In array \verb|output_field|, field type in Table \ref{table:field_type} needs to defined. The same field can be defined more than once in array \verb|output_field| to output vector field in Cartesian coordinate and radial component, for example.
%
\begin{table}[htp]
\caption{List of field type for cross sectioning and isosurface module}
\label{table:field_type}
\begin{center} 
\begin{tabular}{|c|c|}
\hline
 Definition & Field type  \\ \hline \hline
 \verb|scalar| & scalar field  \\ \hline
 \verb|vector| & Cartesian vector field \\ \hline
 \verb|x| & $x$-component  \\ \hline
 \verb|y| & $y$-component  \\ \hline
 \verb|z| & $z$-component  \\ \hline
 \verb|radial| & radial ($r$-) component  \\ \hline
 \verb|theta| & $\theta$-component  \\ \hline
 \verb|phi| & $\phi$-component  \\ \hline
 \verb|cylinder_r| & cylindrical radial ($s$-) component  \\ \hline
 \verb|magnitude| & magnitude of vector  \\ \hline
\end{tabular}
\end{center}
\end{table}
%
\paragraph{Control data} \label{section:section_control}
The format of the control file or block for cross sections is described below. The detail of each block is described in section \ref{section:def_control}.  \verb|cross_section_ctl| block can be read from an external file. 

To define the external file name, as \verb|file cross_section_ctl [file name]| in \verb|control_MHD| or \verb|control_snapshot|. \\
\\
%
Block \verb|cross_section_ctl| (Top level for sectioning)
\label{href_i:cross_section_ctl}
\begin{itemize}
	\item \hyperref[href_t:section_file_prefix]
			{\tt section\_file\_prefix    [section\_prefix]}
	\item \hyperref[href_t:psf_output_type]
			{\tt psf\_output\_type        [file\_format]}
	\item Block \hyperref[href_t:surface_define]{\tt surface\_define}
		\begin{itemize}
			\item \hyperref[href_t:section_method]
				{\tt section\_method    [METHOD]}
			\item Array \hyperref[href_t:psf_coefs_ctl]
				{\tt coefs\_ctl        [TERM]         [COEFFICIENT]}
			\item \hyperref[href_t:psf_radius]{\tt radius    [SIZE]}
			\item Array \hyperref[href_t:psf_normal_vector]
				{\tt normal\_vector    [DIRECTION]    [COMPONENT]}
			\item Array \hyperref[href_t:psf_axial_length]
                {\tt axial\_length     [DIRECTION]    [COMPONENT]}
			\item Array \hyperref[href_t:psf_center_position]
                {\tt center\_position  [DIRECTION]    [COMPONENT]}
%
			\item Array \hyperref[href_t:section_area_ctl]
				{\tt section\_area\_ctl        [AREA\_NAME]}
	\end{itemize}
%
	\item \hyperref[href_t:output_field_define]{\tt output\_field\_define}
		\begin{itemize}
			\item Array \hyperref[href_t:psf_output_field]
                {\tt output\_field     [FIELD]    [COMPONENT]}
		\end{itemize}
\end{itemize}

\paragraph{Output data format of sectioning module}
\label{sec:PSF_data}
Sectioning data are written with VTK format and VTK data compressed by zlib. Field data also output by binary format and binary compressed by zlib. The list of data format and control flag for \verb|psf_output_type| are listed in Table \ref{table:PSF_data}. In the binary data format, position data and field data are saved independently not to write the grid data for each output step. Program \hyperref[section:section_to_VTK]{\tt section\_to\_VTK} generates VTK file from the binary section data. The output data format is defined by \verb|psf_output_type|. Because the field data is written by using Cartesian coordinate $(x,y,z)$ system, $(x,y,z)$ components in ParaView corresponds to the spherical components $(r, \theta, \phi)$ or cylindrical componennts $(s,\phi, z)$ if sectioning data is writtein the spherical or cylindrical componnents. Consequently, ParaView can not draw griph or field lines for these spherical or cylindrical vectors.
%
\begin{table}[htp]
\caption{Data format  and an example of data size and output time  for sectioning data}
\label{table:PSF_data}
\begin{center} 
\begin{tabular}{|c|c|c|c|c|}
\hline
File format & \verb|[fld_format]| & \verb|extension| & size (MByte) & time (sec)  \\ \hline \hline
VTK & \verb|VTK| & \verb|.vtk| & 29.1 & 2.88 \\ \hline
Compressed VTK & \verb|VTK_gzip| & \verb|.vtk.gz| & 6.04 & 1.29 \\ \hline
Binary & \verb|PSF| & \verb|0.sgd| (grid) & 5.30 &  \\
           &        &  \verb|.sdt| (field) & 4.13 & 2.59 \\ \hline
Compressed binary & \verb|PSF_gzip| & \verb|.0.sgd.gz| (grid) & 1.17 & \\
           &        &  \verb|.sdt.gz| (field) & 3.94 & 1.21 \\ \hline
\end{tabular}
\end{center} 
\end{table} 

%
\subsection{Isosurface data}
\label{section:ISO}
%
Calypso can also output isosurface data for visualization. Generally, data size of the isosurface is much larger than the sectioning data. The isosurface data is also written as a unstructured grid data with VTK format. The isosurface also consists of triangle patches.

To output cross sectioning, increment of the surface output data should be defined by \verb|i_step_isosurface_ctl| in \verb|time_step_ctl| block. And, array block \verb|isosurface_ctl| in \verb|visual_control| section is required to define cross sections. Each \verb|isosurface_ctl| block defines one cross section. Each cross section can also define by an external file by specifying external file name with \verb|file| label.
%
\paragraph{Control data}  \label{section:isosurface_control}
The format of the control file or block for isosurfaces is described below. The detail of each block is described in section \ref{section:def_control}.  \verb|isosurface_ctl| block can be read from an external file. To define the external file name, as \verb|file isosurface_ctl [file name]| in \verb|control_MHD| or \verb|control_snapshot|. \\
\\
%
Block \verb|isosurface_ctl|  (Top lebel of the control data)
\label{href_i:isosurface_ctl}
\begin{itemize}
	\item \hyperref[href_t:isosurface_file_prefix]
			{\tt isosurface\_file\_prefix    [file\_prefix]}
	\item \hyperref[href_t:iso_output_type]
			{\tt iso\_output\_type           [file\_format]}
%
	\item Block \hyperref[href_t:isosurf_define]{\tt isosurf\_define}
		\begin{itemize}
			\item \hyperref[href_t:isosurf_field]{\tt isosurf\_field    [FIELD]}
			\item \hyperref[href_t:isosurf_component]
						{\tt isosurf\_component    [COMPONENT]}
			\item \hyperref[href_t:isosurf_value]{\tt isosurf\_value    [VALUE]}
%
			\item Array \hyperref[href_t:isosurf_area_ctl]
						{\tt isosurf\_area\_ctl  [AREA\_NAME]}
		\end{itemize}
%
	\item Block \hyperref[href_t:field_on_isosurf]{\tt field\_on\_isosurf}
		\begin{itemize}
			\item \hyperref[href_t:result_type]{\tt result\_type    [TYPE]}
			\item \hyperref[href_t:result_value]{\tt result\_value    [VALUE]}
			\item Array \hyperref[href_t:iso_output_field]
						{\tt output\_field        [FIELD]    [COMPONENT]}
		\end{itemize}
\end{itemize}

\paragraph{Output data format of isosurface module}
\label{sec:PSF_data}
Isosurface data are written with VTK format and VTK data compressed by zlib. Field data also output by binary format and binary compressed by zlib. The list of data format and control flag for \verb|iso_output_type| are listed in Table \ref{table:ISO_data}. Like as sectioning data, program \hyperref[section:section_to_VTK]{\tt section\_to\_VTK} generates VTK file from the binary section data. The output data format is defined by \verb|iso_output_type|. Because the field data is written by using Cartesian coordinate $(x,y,z)$ system, $(x,y,z)$ components in ParaView corresponds to the spherical components $(r, \theta, \phi)$ or cylindrical componennts $(s,\phi, z)$ if sectioning data is writtein the spherical or cylindrical componnents. Consequently, ParaView can not draw griph or field lines for these spherical or cylindrical vectors.
%
\begin{table}[htp]
\caption{Data format and an example of data size and output time for isosurface data}
\label{table:ISO_data}
\begin{center} 
\begin{tabular}{|c|c|c|c|c|}
\hline
File format & \verb|[fld_format]| & \verb|extension| &  Size  (MByte) & Time (sec)   \\ \hline \hline
VTK &\verb|VTK| &  \verb|.vtk| & 172 & 1.88 \\ \hline
Compressed VTK &\verb|VTK_gzip| &  \verb|.vtk.gz| & 38.8 & 2.92  \\ \hline
Binary &\verb|ISO| &  \verb|.sfm| & 55.7 & 2.22 \\ \hline
Compressed binary & \verb|ISO_gzip| & \verb|.sfm.gz| & 35.0 &  1.73  \\ \hline
\end{tabular}
\end{center} 
\end{table} 
%

\subsection{Time history data for monitoring}
Calypso also generate various time history outputs data.These files are written by the SCII format or compressed format by using zlib library. These compressed files can be expanded by {\tt gzip} commnd. 
If the time history data files exist before starting the simulation, programs append results at the end of files without checking constancy of the number of data and order of the field. If you change the configuration of data output structure, please move the existed data files to another directory before starting the programs.

\subsubsection{Layered spectrum data}
\label{section:layerd_spectr}
Spectrum data for the each radial position are written by defining {\tt layered\_pwr\_spectr\_prefix} in control file. By defining {\tt layered\_pwr\_spectr\_prefix}, following spectrum data averaged over the fluid shell is written. Data format is the same as the volume spectrum data, but radial grid point and radius of the layer is added in the list. The following files are generated. The radial points for output is listed in the array \verb|spectr_layer_ctl|. If \verb|spectr_layer_ctl| is not defined, mean square data at {\bf all} radial levels will be written. See example of \hyperref[section:dynamobench]{dynamo benchmark case 2}. Header of the layered spectrum data file consists of 
%
\begin{description}
\item{\tt  line 2: } Number of radial grid and truncation level
\item{\tt  line 4: } Radial layer ID for ICB and CMB
\item{\tt  line 6: } Number of field of data, total number of components
\item{\tt  line 8: } Number of components for each field
\end{description}
%
Field labels indicates as following:
%
\begin{description}
\item{\tt  t\_step}  Time setp number
\item{\tt  time}   Time
\item{\tt  K\_ene\_pol}  Amplitude of poloidal kinetic energy
\item{\tt  K\_ene\_tor}  Amplitude of toroidal kinetic energy
\item{\tt  K\_ene}       Amplitude of total kinetic energy
\item{\tt  M\_ene\_pol}  Amplitude of poloidal magnetic energy
\item{\tt  M\_ene\_tor}  Amplitude of toroidal magnetic energy
\item{\tt  M\_ene}       Amplitude of total magnetic energy
\item{\tt  [Field]\_pol} Mean square amplitude of poloidal component of {\tt [Field]}
\item{\tt  [Field]\_tor} Mean square amplitude of toroidal component of {\tt [Field]}
\item{\tt  [Field]}      Mean square amplitude of {\tt [Field]}
\end{description}
%
In vector fields, the kinetic energy $u^{2} / 2$ and magnetic energy $B^{2} / 2$ are calculated instead of mean square amplitude for the velocity $\bvec{u}$ and magnetic field $\bvec{B}$. Headers on the first lines indicate following data. The following mean square data is generated:

%
\begin{description}
\item{\tt [layer\_pwr\_prefix]\_s.dat[.gz]} Surface average of mean square amplitude of the fields. the mean square for the scalar field $f$ is evluated from its spherical harmonic coefficients by
%
\begin{equation}
<f^{2}(r)> = \sum_{l}\sum_{m}  \frac{1}{2l + 1} \left(f_{l}^{m}(r) \right)^2.
\end{equation}
%
And, the mean square of the vector field $\bvec{A}$ evaluated by
%
\begin{eqnarray}
<\bvec{A}_{S}^{2}(r)> &=& \sum_{l}\sum_{m} \frac{1}{2l + 1}
\left[  \left(\frac{l\left(l+1 \right) }{r^{2}} A_{Sl}^{\ m}(r) - \frac{\partial \phi_{l}^{m}}{\partial r} \right)^{2} 
\right. \nonumber \\
& & \left. +  \frac{l \left( l+1 \right)}{r^{2}} \left( \frac{\partial A_{Sl}^{\ m}}{\partial r} - \phi_{l}^{m} \right)^{2} \right],
\end{eqnarray}
%
and
%
\begin{eqnarray}
<\bvec{A}_{T}^{2}(r)> &=& \sum_{l}\sum_{m} \frac{l \left( l+1 \right)}{2l + 1} \frac{1}{r^{2}} \left( A_{Tl}^{\ m}(r) \right)^{2}.
\end{eqnarray}
Finally, the total mean square amplitude $<\bvec{A}^{2}> $ is obtained by
\begin{eqnarray}
<\bvec{A}^{2}(r)> &=& <\bvec{A}_{S}^{2}(r)>  + <\bvec{A}_{T}^{2}(r)> .
\end{eqnarray}
%
%
\item{\tt [layer\_pwr\_prefix]\_l.dat[.gz]} Surface average of mean square amplitude of the fields as a function of spherical harmonic degree $l$ and radial grid id $k$. For scalar field, the spectrum is
%
\begin{equation}
< f_{l}^{\ 2}(r,l)>  = \sum_{m=-l}^{l}  \frac{1}{2l + 1} \left(f_{l}^{m}(r) \right)^2.
\end{equation}
%
For vector field, spectrum for the poloidal and toroidal components are written by 
%
\begin{eqnarray}
<\bvec{A}_{Sl}^{\ 2}(r,l)> &=&  \sum_{m=-l}^{l}  \frac{1}{2l + 1}
\left[  \left(\frac{l\left(l+1 \right) }{r^{2}} A_{Sl}^{\ m}(r) - \frac{\partial \phi_{l}^{m}}{\partial r} \right)^{2} 
\right. \nonumber \\
& & \left. +  \frac{l \left( l+1 \right)}{r^{2}} \left( \frac{\partial A_{Sl}^{\ m}}{\partial r} - \phi_{l}^{m} \right)^{2} \right],
\end{eqnarray}
%
and
\begin{eqnarray}
<\bvec{A}_{Tl}^{\ 2}(r,l)>  &=& \sum_{m=-l}^{l} \frac{l \left( l+1 \right)}{2l + 1} \frac{1}{r^{2}} \left( A_{Tl}^{\ m}(r) \right)^{2}.
\end{eqnarray}
Finally, the total mean square amplitude $<\bvec{A}^{2}> $ is obtained by
\begin{eqnarray}
<\bvec{A}_{l}^{2}(r,l)> &=& <\bvec{A}_{Sl}^{\ 2}(r,l)>  + <\bvec{A}_{Tl}^{\ 2}(r,l)> .
\end{eqnarray}

\item{\tt [layer\_pwr\_prefix]\_m.dat} Surace average of mean square amplitude of the fields as a function of spherical harmonic order $m$ and radial grid id $k$. The zonal wave number is referred in this spectrum data. For scalar field, the spectrum is
%
\begin{equation}
<f_{m}^{2}(r,m)> = \sum_{l=m}^{L_{max}}  \frac{1}{2l + 1} \left[ \left(f_{l}^{m}(r) \right)^2 
+ \left(f_{l}^{-m}(r) \right)^2 \right]
\end{equation}
%
For vector field, spectrum for the poloidal and toroidal components are written by 
%
\begin{eqnarray}
<\bvec{A}_{Sm}^{\ 2}(r,m)> &=&   \sum_{l=m}^{L_{max}} \frac{1}{2l + 1}
\left[  \left(\frac{l\left(l+1 \right) }{r^{2}} A_{Sl}^{\ m}(r) - \frac{\partial \phi_{l}^{m}}{\partial r} \right)^{2} 
\right. \nonumber \\
& & + \left(\frac{l\left(l+1 \right) }{r^{2}} A_{Sl}^{\ -m}(r) - \frac{\partial \phi_{l}^{-m}}{\partial r} \right)^{2} 
\nonumber \\
& & +  \frac{l \left( l+1 \right)}{r^{2}} \left( \frac{\partial A_{Sl}^{\ m}}{\partial r} - \phi_{l}^{m} \right)^{2} 
\nonumber \\
& & \left. +  \frac{l \left( l+1 \right)}{r^{2}} \left( \frac{\partial A_{Sl}^{\ -m}}{\partial r} - \phi_{l}^{-m} \right)^{2} \right],
\end{eqnarray}
%
and
\begin{eqnarray}
<\bvec{A}_{Tm}^{\ 2}(r,m)> &=&  \sum_{l=m}^{L_{max}} \frac{l \left( l+1 \right)}{2l + 1} \frac{1}{r^{2}} 
\left[ \left( A_{Tl}^{\ m}(r) \right)^{2} +  \left( A_{Tl}^{\ -m}(r) \right)^{2} \right].
\end{eqnarray}
Finally, the total mean square amplitude $<\bvec{A}^{2}> $ is obtained by
\begin{eqnarray}
<\bvec{A}_{m}^{\ 2}(r,m)> &=& <\bvec{A}_{Sm}^{\ 2}(r,m)>  + <\bvec{A}_{Tm}^{\ 2}(r,m)>.
\end{eqnarray}

\item{\tt [layer\_pwr\_prefix]\_lm.dat} Surface average of mean square amplitude of the fields as a function of spherical harmonic order $n = l-m$ and radial grid id $k$. The wave number in the latitude direction is referred in this spectrum data.
For scalar field, the spectrum is
%
\begin{equation}
<f_{n}^{2}(r,n)> = \sum_{m=n}^{L_{max}} \frac{1}{2l + 1} \left[ \left(f_{l}^{l-n}(r) \right)^2 
+ \left(f_{l}^{-l+n}(r) \right)^2 \right]
\end{equation}
%
For vector field, spectrum for the poloidal and toroidal components are written by 
%
\begin{eqnarray}
<\bvec{A}_{Sn}^{\ 2}(r,n)> &=&   \sum_{m=n}^{L_{max}}\frac{1}{2l + 1}
\left[  \left(\frac{l\left(l+1 \right) }{r^{2}} A_{Sl}^{\ l-n}(r) - \frac{\partial \phi_{l}^{l-n}}{\partial r} \right)^{2} 
\right. \nonumber \\
& & + \left(\frac{l\left(l+1 \right) }{r^{2}} A_{Sl}^{\ -l+n}(r) - \frac{\partial \phi_{l}^{-l+n}}{\partial r} \right)^{2} 
\nonumber \\
& & +  \frac{l \left( l+1 \right)}{r^{2}} \left( \frac{\partial A_{Sl}^{\ l-n}}{\partial r} - \phi_{l}^{l-n} \right)^{2} 
\nonumber \\
& & \left. +  \frac{l \left( l+1 \right)}{r^{2}} \left( \frac{\partial A_{Sl}^{\ -l+n}}{\partial r} - \phi_{l}^{-l+n} \right)^{2} \right],
\end{eqnarray}
%
and
\begin{eqnarray}
<\bvec{A}_{Tn}^{\ 2}(r,n)> &=&  \sum_{m=n}^{L_{max}}\frac{l \left( l+1 \right)}{2l + 1} \frac{1}{r^{2}} 
\left[ \left( A_{Tl}^{\ l-n}(r) \right)^{2} +  \left( A_{Tl}^{\ -l+n}(r) \right)^{2} \right].
\end{eqnarray}
Finally, the total mean square amplitude $<\bvec{A}^{2}> $ is obtained by
\begin{eqnarray}
<\bvec{A}_{n}^{\ 2}(r,n)> &=& <\bvec{A}_{Sn}^{\ 2}(r,n)>  + <\bvec{A}_{Tn}^{\ 2}(r,n)> 
\end{eqnarray}
%
\item{\tt [layer\_pwr\_prefix]\_m0.dat} Surace average of mean square amplitude of the axisymmetric components of fields as a function of radial grid id $k$. The zonal wave number is referred in this spectrum data. For scalar field, the spectrum is
%
\begin{equation}
<f^{2}(r)>_{axis} = \sum_{l=0}^{L_{max}}  \frac{1}{2l + 1} \left(f_{l}^{0}(r) \right)^2
\end{equation}
%
For vector field, spectrum for the poloidal and toroidal components are written by 
%
\begin{eqnarray}
<\bvec{A}_{S}^{2}(r)>_{axis} &=&   \sum_{l=0}^{L_{max}} \frac{1}{2l + 1}
\left[  \left(\frac{l\left(l+1 \right) }{r^{2}} A_{Sl}^{\ 0}(r) - \frac{\partial \phi_{l}^{0}}{\partial r} \right)^{2} 
\right. \nonumber \\
& & \left. +  \frac{l \left( l+1 \right)}{r^{2}} \left( \frac{\partial A_{Sl}^{\ 0}}{\partial r} - \phi_{l}^{0} \right)^{2} \right],
\end{eqnarray}
%
and
\begin{eqnarray}
<\bvec{A}_{T}^{2}(r)>_{axis} &=&  \sum_{l=0}^{L_{max}} \frac{l \left( l+1 \right)}{2l + 1} \frac{1}{r^{2}} 
\left( A_{Sl}^{\ 0}(r) \right)^{2}.
\end{eqnarray}
Finally, the total mean square amplitude $<\bvec{A}^{2}> $ is obtained by
\begin{eqnarray}
<\bvec{A}^{2}(r)>_{axis} &=& <\bvec{A}_{S}^{2}(r)>_{axis}  + <\bvec{A}_{T}^{2}(r)>_{axis} .
\end{eqnarray}

\end{description}


\subsubsection{Mean square amplitude data}
\label{sec:mean_square}
This program output mean square amplitude of the fields which is marked as \verb|Monitor_ON| over the fluid shell at every \verb|[increment_monitor]| steps. The data is written in the file \verb|[vol_pwr_prefix]_s.dat[.gz]| or  \verb|sph_pwr_volume_s.dat| if \\
{\tt [vol\_pwr\_prefix]} is not defined in the control file. The mean square amplitude ifor a scalar field $f$ is defined by
%
\begin{equation}
<f^{2}> =   \frac{4\pi}{V} \int <f^{2}(r)> r^{2} dr.
\end{equation}
%
For the vector field $\bvec{A}$, the mean square of the potential component $\bvec{A}_{S}$ is included in the mean square of the poloidal component in the data if the vector field is not a solenoidal field. Consequently, $\bvec{A}_{S}$ and mean square of the toroidal component $\bvec{A}_{T}$ are evaluated by 
%
\begin{eqnarray}
<\bvec{A}_{S}^{2}> &=& \frac{4\pi}{V} \int <\bvec{A}_{S}^{2}(r)> r^{2} dr,
\nonumber \\
<\bvec{A}_{T}^{2}>  &=& \frac{4\pi}{V} \int <\bvec{A}_{T}^{2}(r)>  r^{2} dr,
\end{eqnarray}
% 
and
%
\begin{eqnarray}
<\bvec{A}^{2}> &=& \frac{4\pi}{V} \int <\bvec{A}^{2}(r)>  r^{2} dr.
\label{eq:vol_vec_msq}
\end{eqnarray}

The header in the first 12 lines is the following. 
%
\begin{description}
\item{\tt  line 2: } Number of radial grid and truncation level
\item{\tt  line 4: } Radial layer ID for ICB and CMB
\item{\tt  line 6: } Radial layer ID and radius for the inner boundary of integration
\item{\tt  line 8: } Radial layer ID and radius for the outer boundary of integration
\item{\tt  line 10: } Number of field of data, total number of components
\item{\tt  line 11: } Number of components for each field
\end{description}
%
The following is an example of the beginning of the data file:
{\scriptsize
\begin{verbatim}
Radial_layers, Truncation
             112             159
ICB_id, CMB_id
               1             112
Lower_boundary_ID, Lower_boundary_radius
               1   5.384615384615384E-001
Upper_boundary_ID, Upper_boundary_radius
             112   1.538461538461538E+000
Number_of_fields, Number_of_components
               8              16
    3    1    3    1    3    3    1    1
t_step    time    K_ene_pol    K_ene_tor    K_ene    temperature    vorticity_pol
    vorticity_tor    vorticity    pressure    M_ene_pol    M_ene_tor    M_ene
    current_density_pol    current_density_tor    current_density    buoyancy_flux    
    Lorentz_work    
             100  2.00000000000000E-004  3.08485175580558E+001  2.97052514317492E-001
  3.11455700723732E+001  8.37549401638792E-002  3.83545285358558E+001  
  4.45268846884004E+003  4.49104299737589E+003  2.20356357802801E+001  
  2.88810032145648E-006  1.76927464999397E-006  4.65737497145044E-006  
  4.45474362010442E-005  3.76310585686982E-005  8.21784947697424E-005  
  1.47655914519649E+013  1.52720673275983E-003
             200  3.99999999999999E-004  1.21246529508559E+002  4.60310202818333E+000  
  1.25849631536743E+002  8.38032562478558E-002  5.26153720206686E+002  
  1.51087784591356E+004  1.56349321793422E+004  4.32047730989212E+001  
  2.88721662147718E-006  1.76772446160287E-006  4.65494108308005E-006  
  4.49318945325754E-005  3.83578033623782E-005  8.32896978949536E-005  
  5.86224313684072E+013  6.13459599464992E-003
\end{verbatim}
}
%
\subsubsection{Volume average data}
Volume average data are written by defining {\tt volume\_average\_prefix} in control file. Volume average data are written in \verb|[vol_ave_prefix].dat.[gz]| with the same format as the men square amplitude data in Subsection \ref{sec:mean_square}. The volume average of scalar field $f$ is evaluated by the 0-th degree of the spherical harmonics coefficients $f_{0}^{0}$ as
%
\begin{equation}
<f> =   \frac{4\pi}{V} \int f_{0}^{0}(r) r^{2} dr.
\end{equation}
%
The average of the toroidal component of the vector field $<\bvec{A}_{T}>$ is always zero, and the average of poloidal component of the solenoidal vector  $<\bvec{A}_{S}>$ is also zero. If the vector is non-soleinoidal, 0-th degree of the potential field contributes the average radial vector as
%
\begin{eqnarray}
<\bvec{A}> &=& <\bvec{A}_{S}>  =  - \frac{4\pi}{V}
\int \frac{\partial \phi_{0}^{0}}{\partial r} r^{2} dr.
\end{eqnarray}
%

If you need the sphere average data for specific radial point, you can use picked spectrum data output in \hyperref[sec:pickup_spectr_ctl]{\tt pickup\_spectr\_ctl}  using $l = m = 0$ at specific radius.

\subsubsection{Volume spectrum data}
Volume spectrum data are written by defining {\tt volume\_pwr\_spectr\_prefix} in control file. By defining {\tt volume\_pwr\_spectr\_prefix}, following spectrum data averaged over the fluid shell is written. Data header format is the same as the volume mean square data, but degree $l$, order $m$, or meridional wave number $l-m$ is added in the list of data in each step. \\
%
\begin{description}
\item{\tt [vol\_pwr\_prefix\_l.dat[.gz]}  Volume average of mean square amplitude of the fields as a function of spherical harmonic degree $l$. For scalar field, the spectrum is
%
\begin{eqnarray}
<f_{l}^{2}(l)> =   \frac{4\pi}{V} \int <f_{l}^{2}(r,l)> r^{2} dr.
\end{eqnarray}
%
For vector field, spectrum for the poloidal and toroidal components are written by 
%
\begin{eqnarray}
<A_{Sl}^{\ 2} > & = &  \frac{4\pi}{V} \int <A_{Sl}^{\ 2}(r,l) >  r^{2} dr,
\nonumber \\
<A_{Tl}^{\ 2} > & = &  \frac{4\pi}{V} \int <A_{Tl}^{\ 2}(r,l) >  r^{2} dr,
\end{eqnarray}
and
\begin{eqnarray}
<A_{l}^{\ 2} > & = &  \frac{4\pi}{V} \int <A_{l}^{\ 2}(r,l) >  r^{2} dr,
\label{eq:vol_vec_msq_l}
\end{eqnarray}

\item{\tt [vol\_pwr\_prefix]\_m.dat[.gz]} Volume average of mean square amplitude of the fields as a function of spherical harmonic order $m$. The zonal wave number is referred in this spectrum data. For scalar field, the spectrum is
%
\begin{eqnarray}
<f_{m}^{2}(m)> =   \frac{4\pi}{V} \int <f_{m}^{2}(r,m)> r^{2} dr.
\end{eqnarray}
%
For vector field, spectrum for the poloidal and toroidal components are written by 
%
\begin{eqnarray}
<A_{Sm}^{\ 2} > & = &  \frac{4\pi}{V} \int <A_{Sm}^{\ 2}(r,m) >  r^{2} dr,
\nonumber \\
<A_{Tm}^{\ 2} > & = &  \frac{4\pi}{V} \int <A_{Tm}^{\ 2}(r,m) >  r^{2} dr,
\end{eqnarray}
and
\begin{eqnarray}
<A_{m}^{\ 2} > & = &  \frac{4\pi}{V} \int <A_{m}^{\ 2}(r,m) >  r^{2} dr,
\label{eq:vol_vec_msq_m}
\end{eqnarray}


\item{\tt [vol\_pwr\_prefix]\_lm.dat[.gz]} Volume average of mean square amplitude of the fields as a function of spherical harmonic order $n = l-m$. The wave number in the latitude direction is referred in this spectrum data. For scalar field, the spectrum is
%
\begin{eqnarray}
<f_{n}^{2}(n)> =   \frac{4\pi}{V} \int <f_{n}^{2}(r,n)> r^{2} dr.
\end{eqnarray}
%
For vector field, spectrum for the poloidal and toroidal components are written by 
%
\begin{eqnarray}
<A_{Sn}^{\ 2} > & = &  \frac{4\pi}{V} \int <A_{Sn}^{\ 2}(r,n) >  r^{2} dr,
\nonumber \\
<A_{Tn}^{\ 2} > & = &  \frac{4\pi}{V} \int <A_{Tn}^{\ 2}(r,n) >  r^{2} dr,
\end{eqnarray}
and
\begin{eqnarray}
<A_{n}^{\ 2} > & = &  \frac{4\pi}{V} \int <A_{n}^{\ 2}(r,n) >  r^{2} dr,
\label{eq:vol_vec_msq_lm}
\end{eqnarray}
%
\item{\tt [vol\_pwr\_prefix]\_m0.dat[.gz]} Volume average of mean square amplitude of the axisymmetric components is stored. The mean square of the axisymmetric scalar is defined by 
%
\begin{eqnarray}
<f_{m0}^{2}> 
&=&  \frac{1}{V} \sum_{l=0}^{L_{max}} \left[ N_{l} \int \left(f_{l}^{0}(r) \right)^2 r^{2} dr \right].
\end{eqnarray}
%
For vector field, spectrum for the poloidal and toroidal components are written by 
\begin{eqnarray}
<A_{Sm0}^{\ 2} >\ &=& \frac{1}{V} \sum_{l=0}^{L_{max}} N_{l}
\int \left[  \left(\frac{l\left(l+1 \right) }{r^{2}} A_{Sl}^{\ 0}(r) - \frac{\partial \phi_{l}^{0}}{\partial r} \right)^{2} 
\right. \nonumber \\
& & \left. +  \frac{l \left( l+1 \right)}{r^{2}} \left( \frac{\partial A_{Sl}^{\ 0}}{\partial r} - \phi_{l}^{0} \right)^{2} \right] r^{2} dr, \\
<A_{Tm0}^{\ 2} > &=& \frac{1}{V}   \sum_{l=0}^{L_{max}} \left( l+1 \right) N_{l}  \int \left( A_{Tl}^{\ 0}(r) \right)^{2} dr.
\end{eqnarray}
%
This data file is used toe same data format as the volume mean square data in Subsection \ref{sec:mean_square}. 
%
\end{description}

Default volume averge and mean square data is integrated over the fluid domain. Calypso also can output volume integration data between manually defined inner and outer boundary. Each volume integration parameter is defined in array block \hyperref[href_t:volume_spectrum_ctl]{\tt volume\_spectrum\_ctl}. For each integration, the inner and outer boundary radii are set by \hyperref[href_t:inner_radius_ctl]{\tt inner\_radius\_ctl} and \hyperref[href_t:outer_radius_ctl]{\tt outer\_radius\_ctl}, respectively.


\subsubsection{Gauss coefficient data {\tt [gauss\_coef\_prefix].dat}}
This program output selected Gauss coefficients of the magnetic field. Gauss coefficients is evaluated for radius defined by \verb|[gauss_coef_radius]| every \verb|[increment_monitor]| steps. Gauss coefficients are evaluated by using poloidal magnetic field at CMB $B_{Sl}^{\ m}(r_{o})$ and radius defined by \verb|[gauss_coef_radius]| $r_{e}$ as
%
\begin{eqnarray}
g_{l}^{m} &=& \frac{l}{r_{e}^2} \left(\frac{r_{o}}{r_{e}}\right)^{l} B_{Sl}^{\ m}(r_{o}),
\nonumber \\
h_{l}^{m} &=& \frac{l}{r_{e}^2} \left(\frac{r_{o}}{r_{e}}\right)^{l} B_{Sl}^{\ -m}(r_{o}).
\nonumber
\end{eqnarray}
%
The header format is the same as the volume mean square data, but each item is used for as 
%
\begin{description}
\item{\tt  line 2: } Number of radial grid and truncation level
\item{\tt  line 4: } Radial layer ID for ICB and CMB
\item{\tt  line 6: } Not used
\item{\tt  line 8: } Radius for the reference radius $r_{e}$
\item{\tt  line 10: } Nunmber of Gauss coeffifients
\item{\tt  line 11: } Number of components (All number are 1)
\end{description}
%
%
The data consists of time step, time, and Gauss coefficients for each step in one line. If the Gauss coefficients data file exist before starting the simulation, programs append Gauss coefficients at the end of files without checking constancy of the number of data and order of the field. If you change the configuration of data output structure, please move the old Gauss coefficients file to another directory before starting the programs.

\subsubsection{Spectrum monitor data \\
{\tt [picked\_sph\_prefix]\_l[degree]\_m[order].dat}}
\label{sec:pickup_spectr_ctl}
This outputs of spherical harmonics coefficients at specified spherical harmonics modes and radial points in text files. Data for each spherical harmonic mode are saved in the files named {\tt [picked\_sph\_prefix]\_l[degree]\_m[order].dat}. Consequently, the file prefix {\tt [picked\_sph\_prefix]} is recommended to be defined including subdirectory name to save under a subdirectory. Spectrum data marked \verb|[Monitor_On]| are written in one line for each radial point every \verb|[increment_monitor]| steps. If the spectrum monitor data file exist before starting the simulation, programs append spectrum data at the end of files without checking constancy of the number of data and order of the field. If you change the configuration of data output structure, please move the old spectrum monitor file to another directory before starting the programs.

If a vector field $\bvec{F}$ is not a solenoidal field, $\bvec{F}$ is described by the spherical harmonics coefficients of the poloidal $F_{Sl}^{\ m}$, toroidal $F_{Tl}^{\ m}$, and potential $\varphi_{l}^{m}$ components as
\begin{eqnarray}
\bvec{F}(r, \theta, \phi) & = &  - \frac{1}{r^{2}}\frac{\partial \varphi_{0}^{0}}{\partial r} \hat{r}
 + \sum_{l=1}^{L} \sum_{m=-l}^{l} 
\left[\nabla \times \nabla \times \left( F_{Sl}^{\ m} \hat{r} \right) +  \nabla \times \left(F_{Tl}^{\ m}\right)
 - \nabla \left(\varphi_{l}^{m} Y_{l}^{m} \right)\right].
\nonumber
\end{eqnarray}
In Calypso, the following coefficients are written for the non-solenoidal vector.
\begin{description}
\item{\tt  $\verb|[field_name]_pol|$ : }
 $\left\{\begin{array}{ccr}
\displaystyle{
F_{Sl}^{\ m} - \frac{r^{2}}{l \left(l+1\right)} \frac{\partial \varphi_{l}^{m}}{\partial r} }
& \mbox{for} & \left (l \ne 0 \right)\\
\displaystyle{
 -r^{2} \frac{\partial \varphi_{0}^{0}}{\partial r}
} & \mbox{for} & \left (l = 0 \right)
\end{array}
\right.$
\item{\tt  $\verb|[field_name]_dpdr|$ : } 
$
\left\{
\begin{array}{ccr}
\displaystyle{
\frac{\partial F_{Sl}^{\ m}}{\partial r} - \varphi_{l}^{m}}
 & \mbox{for} & \left (l \ne 0 \right)\\
 0 & \mbox{for} & \left (l = 0 \right)
\end{array}
\right. $
\item{\tt  $\verb|[field_name]_tor|$ : }  $F_{Tl}^{\ m}$
\end{description}


\subsubsection{Nusselt number data {\tt [nusselt\_number\_prefix].dat}}
{\bf CAUTION: Nusselt number is not evaluated if heat source is exsist.}
The Nusselt number Nu at CMB and ICB is written for each step in one line. The Nusselt number is evaluated by
%
\begin{eqnarray*}
Nu = \frac{<\partial T / \partial r>}{\partial T_{diff}/ \partial r},
\end{eqnarray*}
where, $<\partial T / \partial r>$ and $T_{diff}$ are the horizontal average of the temperature gradient at ICB and CMB and diffusive temperature profile, respectively. $T_{diff}$ is evaluated without heat source, as
\begin{eqnarray*}
T_{diff} = \frac{r_{o}T_{o} - r_{i}T_{i}}{r_{o} - r_{i}}
    +  \frac{r_{o}r_{i}\left(T_{i} - T_{o}\right)}{r_{o} - r_{i}} \frac{1}{r}.
\end{eqnarray*}
%
This diffusive temperature profile is for the case without heat source in the fluid. If simulation is performed including the heat source, this data file does not written.

The header format is the same as the volume mean square data, but number of components are 2 for the Nusselt number for the inner and outer boundaries.

\subsubsection{Dipolrity data {\tt [dipolarity\_file\_prefix].dat}}
The dipolarity $f_{\rm dip}$ is evaluated the poloidal magnetic field at CMB is written for each step in one line. The dipolarity represents the relative strength of the axial dipole magnetic field, which is defined by the ration of the magnetic energy of the dipole component to the total magnetic energy at the CMB as
%
\begin{equation}
f_{\rm dip} = 
\left(
\frac{E_{{\rm B}\ 1}^{\ 0} (r=r_o)}
     {\sum_{l=1}^{L_{\rm dip}}
      \sum_{m=-l}^l E_{{\rm B}\ l}^{\ m} (r=r_o)}
\right)^{1/2}.
\label{eq:f_dip}
\end{equation}
%
The magnetic energy at the CMB, $E_{\rm B} (r=r_o)$, is calculated as
%
\begin{equation}
E_{{\rm B}\ l}^{\ m} (r=r_o) = 
  \frac{1}{2S_o} \int_{S_o} \left[
  \left(\bvec{B}_{l}^{m} \right)^2 + \left(\bvec{B}_{l}^{-m} \right)^2 \right] dS,
\end{equation}
%
where $S_o = 4\pi r_o^2$ is the surface area of the outer core.

\subsubsection{Typical length scale data {\tt [typical\_scale\_prefix].dat}}
The typical length scale is evaluated from kinetic and magnetic energy spectra as a wave number for the spherical harmonic degree $l$, order $m$, and difference between harmonic degree and order $n = l-m$. Each value is evaluated by
%
\begin{eqnarray}
k_{l} & = & \frac{\sum_{l=1}^{L_{max}} l <\bvec{A}_{l}^{\ 2} >}{<\bvec{A}^{2} >},
\\
k_{m} & = & \frac{\sum_{m=0}^{L_{max}} m <\bvec{A}_{m}^{\ 2} >}{<\bvec{A}^{2} >}, 
\\
k_{l-m} & = & \frac{\sum_{n=0}^{L_{max}} (l-m) <\bvec{A}_{n}^{\ 2} >}{<\bvec{A}^{2} >},
\end{eqnarray}
%
where $\bvec{A}$ is the velocity $\bvec{u}$ or magnetic field $\bvec{B}$, and volume mean squares $<\bvec{A}^{2}>$, $<\bvec{A}_{l}^{\ 2}>$, $<\bvec{A}_{m}^{\ 2}>$, and $<\bvec{A}_{n}^{\ 2}>$, are defined by equations (\ref{eq:vol_vec_msq}), (\ref{eq:vol_vec_msq_l}), (\ref{eq:vol_vec_msq_m}) , and (\ref{eq:vol_vec_msq_lm}), respectively.

The header format is the same as the volume mean square data, and the field name is defined by {\tt truncation\_}$L_{dip}$. The labels of each length scales are in Table \ref{table:scale_name}.
%
\begin{table}[htp]
\caption{Data names for typical length scles.}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
 & \mbox{Velocity} & \mbox{Magnetic field} \\ \hline
$k_{l}$ & {\tt lscale\_flow\_degree} & {\tt lscale\_magnetic\_degree} \\
$k_{m}$ & {\tt lscale\_flow\_order} & {\tt lscale\_magnetic\_order} \\
$k_{l-m}$ & {\tt lscale\_flow\_diff\_lm} & {\tt lscale\_magnetic\_diff\_lm} 
\\ \hline 
\end{tabular}
\end{center}
\label{table:scale_name}
\end{table}%
%

\subsubsection{Data output for dynamo benchmark}
\label{section:check_bench}
This program is only used to check solution for dynamo benchmark by Christensen {\it et. al}. The following files are used for this program.

\begin{table}[htp]
\caption{List of files for dynamo benchmark check {\tt sph\_dynamobench} }
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
 name & Parallelization & I/O \\ \hline \hline
\verb|control_snapshot| & Serial & Input \\ \hline
\verb|[sph_prefix].[rj_extension]|  & - & Input \\
\verb|[sph_prefix].[rlm_extension]| & - & Input \\
\verb|[sph_prefix].[rtm_extension]| & - & Input \\
\verb|[sph_prefix].[rtp_extension]| & - & Input \\ \hline
\verb|[rst_prefix].[step#].[rst_extension]| &  - & Input  \\ \hline
\verb|dynamobench.dat| & Single & Output \\ \hline
\end{tabular}
\end{center}
\label{table:sph_dynamobench}
\end{table}

\paragraph{Dynamo benchmark data {\tt dynamobench.dat}}
 In benchmark test by Christensen {\it et. al.}, both global values and local values are checked. As global results, Kinetic energy 
 $\displaystyle{ \frac{1}{V} \int \frac{1}{2} u^{2} dV}$ in the fluid shell, magnetic energy in the fluid shell 
 $\displaystyle{ \frac{1}{V} \frac{1}{E Pm} \int \frac{1}{2} B^{2} dV}$ (for case 1 and 2), and magnetic energy in the solid inner sphere 
 $\displaystyle{ \frac{1}{V_{i}} \frac{1}{E Pm} \int \frac{1}{2} B^{2} dV_{i}}$ (for case 2 only). Benchmark also requests 
 By increasing number of grid point at mid-dpeth of the fluid shell in the equatorial plane by \hyperref[href_t:nphi_mid_eq_ctl]{{\tt nphi\_mid\_eq\_ctl}}, program can find accurate solution for the point where $u_{r} = 0$ and $\partial u_{r} / \partial \phi > 0$. Angular frequency of the field pattern with respect to the $\phi$ direction is also required. The benchmark test also requires temperature and $\theta$ component of velocity. In the text file {\tt [dynamo\_benchmark\_file\_prefix].dat}, the following data are written in one line for every \verb|[i_step_rst_ctl]| step. If {\tt [dynamo\_benchmark\_file\_format]} is set to be {\tt gzip}, the data file can be commpressed by gzip format.
%
\begin{description}
\item{\tt t\_step:  }  Time step number
\item{\tt time:     }  Time
\item{\tt KE\_total: }  Total kinetic energy
\item{\tt ME\_total: }  Total magnetic energy  (Case 1 and 2)
\item{\tt ME\_total\_icore: }  Total magnetic energy in inner core (Case 2)
\item{\tt omega\_ic\_z: } Angular velocity of inner core rotation (Case 2)
\item{\tt MAG\_torque\_ic\_z: }  Magnetic torque integrated over the inner core (Case 2)
\item{\tt B\_theta: } $\Theta$ component of magnetic field at requested point.
\item{\tt v\_phi: } $\phi$ component of velocity at requested point.
\item{\tt temperature: } Temperature at requested point.
\item{\tt Average\_drift\_vr:} Average drift frequency evaluated by the position at $u_{r} = 0$ and $d u_{r} / d \phi > 0$.
\item{\tt omega\_vp44:} Drift frequency evaluated by $V_{S4}^{\ 4}$ component
\item{\tt omega\_vt54:} Drift frequency evaluated by $V_{T5}^{\ 4}$ component


\end{description}

{\small 
\begin{verbatim}
radial_layers, truncation
              64              47
ICB_id, CMB_id
               1              64
Not_used, Not_used
               1   5.384615384615384E-001
Upper_boundary_ID, Upper_boundary_radius
              64   1.538461538461538E+000
Number_of_field, Number_of_components
               8               8
    1    1    1    1    1    1    1    1
t_step    time    KE_total    ME_total    v_phi    B_theta    temperature 
   Average_drift_vr    omega_vp44    omega_vt54    
          200000   9.999999999983364E+000   3.113789741746705E+001   3.177
285062627831E+000  -7.640579505325297E+000  -4.978517354899571E+000   3.73
2175546577078E-001  -3.143091532770634E+000  -3.145607506083934E+000  -3.1
45609151616705E+000
 ...
\end{verbatim}
}
%
\subsubsection{Data output for Field along with a circle}
Calypso can output field and Fourier coefficients along with a circle as a function of longiture $\phi$. The circle is defined by \hyperref[href_t:pick_cylindrical_radius_ctl]{{\tt pick\_cylindrical\_radius\_ctl}} \\
and \hyperref[href_t:pick_vertical_position_ctl]{{\tt pick\_vertical\_position\_ctl}}, respectively. The coordinate system of the field can be chosen from {\tt spherical} or {\tt cylindrical} coordinate by \hyperref[href_t:pick_circle_coord_ctl]{{\tt pick\_circle\_coord\_ctl}}.
When \hyperref[href_t:field_on_circle_prefix]{{\tt field\_on\_circle\_prefix}} is defined, the field data $f(\phi)$ is written in \\
{\tt field\_on\_circle\_prefix.dat[.gz]}, and the data format is the same as the layerd mean square data.
The spectrum data $f(m)$ is written in {\tt spectr\_on\_circle\_prefix.dat[.gz]} \\
if \hyperref[href_t:spectr_on_circle_prefix]{{\tt spectr\_on\_circle\_prefix}} is defined The data format is the same as the volume spectra monitor data.
When \hyperref[href_t:field_on_circle_format]{{\tt field\_on\_circle\_format}}, is set to be {\tt gzip}, data file can be compressed by gzip format.


\newpage

\section{Utility programs}
Calypso includes some utility programs. These programs are useful to data analysis and debugging the simulation programs.

\subsection{Data transform program ({\tt sph\_snapshot})}
\label{section:sph_snapshot}
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{Images/flow_3}
\end{center}
\caption{Data flow for data transform program.}
\label{fig:flow_3}
\end{figure}
%
Simulation program outputs spectrum data as a whole field data. This program is made from simulation program by replacing from time integration routines to restart data input routine. Consequently, Input/Output files in Table \ref{table:sph_mhd} are the same for {\tt sph\_snapshot}, except for the required input restart data \verb|[rst_prefix].[step #].[rst_extension]|.
%
This program requires control file \verb|control_snapshot| insteacd of \verb|control_mhd|. File format of the control file is same as the control field for simulation \hyperref[href_i:MHD_control]{\tt control\_MHD}.

The same files as the simulation program are read in this program, and field data are generated from the snapshots of spectrum data. The monitoring data for snapshots can also be generated. \verb|[step #]| is added in the file name, and the \verb|[step #]| is calculated by \verb|time step|/\verb|[ISTEP_FIELD]|.

We recommend to output cross section data at $y = 0$ by using sectioning module (see \ref{section:PSF}) for zonal mean snapshot program \verb|sph_zm_snapshot| to reduce data size.

\newpage
\subsection{Initial field generation program \\
({\tt sph\_initial\_field})}
\label{sec:sph_initial_field}
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{Images/flow_ini}
\end{center}
\caption{Data flow for initial field generation program.}
\label{fig:flow_ini}
\end{figure}
%
 The initial fields for dynamo benchmark can set in the simulation program by setting \verb|[INITIAL_TYPE]| flag. This program is used to generate initial field by user.  The heat source $q_{T}$ and light element source $q_{C}$ are also defined by this program because $q_{T}$ and $q_{C}$ are defined as scalar fields. Spherical harmonics indexing data files are also generated by using information in \verb|spherical_shell_ctl| block if these indexing data files do not exist. The Fortran source file to define initial field \\
 \verb|const_sph_initial_spectr.f90| is saved in \verb|src/programs/data_utilities| \\
 \verb|/INITIAL_FIELD/| directory,  and please compile again after modifying this module. This program also needs the files listed in Table \ref{table:inital_fld}.
%
\begin{table}[htp]
\caption{List of files for simulation {\tt sph\_initial\_field} }
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
 name & Parallelization & I/O \\ \hline \hline
\verb|control_MHD| & Serial & Input \\ \hline
\verb|[sph_prefix].[rj_extension]|  & - & Input/(Output) \\
\verb|[sph_prefix].[rlm_extension]| & - & Input/(Output) \\
\verb|[sph_prefix].[rtm_extension]| & - & Input/(Output) \\
\verb|[sph_prefix].[rtp_extension]| & - & Input/(Output) \\ \hline
\verb|[rst_prefix].[step #].[rst_extension]| & - & Input/Output  \\ \hline
\end{tabular}
\end{center}
(Output): Marked files are generated if files do not exist.
\label{table:inital_fld}
\end{table}
%
This program generates the spectrum data files \verb|[rst_prefix].[step #].[rst_extension]|. To use generated initial data file, please set 
\hyperref[href_t:i_step_init_ctl]{{\tt [ISTEP\_START]}} to be 0 and \hyperref[href_t:restart_file_ctl]{{\tt [INITIAL\_TYPE]}} to be \\
\hyperref[href_t:restart_file_ctl]{{\tt start\_from\_rst\_file}}.

\subsubsection{Definition of the initial field}
\label{sec:def_initial}
To construct Initial field data, you need to edit the source code \verb|const_sph_initial_spectr.f90| in \verb|src/programs/data_utilities/INITIAL_FIELD/| directory. The module \verb|const_sph_initial_spectr| consists of the following subroutines:
%
\begin{description}
\item{\verb|sph_initial_spectrum|:}    Top subroutine to construct initial field.
\item{\verb|set_initial_velocity|:}        Routine to construct initial velocity.
\item{\verb|set_initial_temperature|:} Routine to construct initial temperature.
\item{\verb|set_initial_composition|:} Routine to construct initial composition.
\item{\verb|set_initial_magne_sph|:} Routine to construct initial magnetic field.
\item{\verb|set_initial_heat_source_sph|:} Routine to construct heat source.
\item{\verb|set_initial_light_source_sph|:}  Routine to construct composition source.
\end{description}
%
The construction routine for each field are called from the top routine \\
\verb|const_sph_initial_spectr.f90|. If lines to call subroutines are commented out, corresponding initial fields are set to 0. In addition, the initial fields to be constructed need to be defined by \verb|nod_value_ctl| array in the \verb|control_MHD|.
%
\begin{table}[htp]
\caption{Field name and corresponding field id in Calypso}
\begin{center}
\begin{tabular}{|c|c|cc|}
\hline
field name & scalar & poloidal  & toroidal  \\ \hline
Velocity & - & \verb|ipol%i_velo| &   \verb|itor%i_velo| \\ 
Magnetic field & - & \verb|ipol%i_magne| &  \verb|itor%i_magne| \\ 
Current density & - & \verb|ipol%i_current| &  \verb|itor%i_current| \\ 
Temperature & \verb|ipol%i_temp| & - & - \\ 
Composition & \verb|ipol%i_light| & - & - \\ 
Heat source & \verb|ipol%i_heat_source| & - & - \\ 
Composition source & \verb|ipol%i_light_source| & - & - \\ \hline
\end{tabular}
\end{center}
\label{table:field_point}
\end{table}%
% 

Initial fields need to be defined by the spherical harmonics coefficients at each radial points as array \verb|d_rj(i,i_field)|, where \verb|i| and \verb|i_field| are the local address of the spectrum data and field id, respectively. The address of the fields are listed in Table \ref{table:field_point}.

In Calypso, local data address for each MPI process is used for the spectrum data address \verb|i|. To find the local address \verb|i|, two functions are required. \\
First, \verb|j = find_local_sph_mode_address(l,m)| returns the local spherical  harmonics address \verb|j| from aa spherical harmonics mode $Y_{l}^{m}$. If process does not have the data for $Y_{l}^{m}$, \verb|j| is set to 0. Second, \verb|i = local_sph_data_address(k,j)| returns the local data address \verb|i| from radial grid number \verb|k| and local spherical harmonics id \verb|j|. For do loops in the radial direction, the total number of radial grid points, radial address for ICB, and radial address for CMB are defined as \verb|nidx_rj(1)|, \verb|nlayer_ICB|, and \verb|nlayer_CMB|, respectively. The radius for the \verb|k|-th grid points can be obtained by \verb|r = radius_1d_rj_r(k)|. The subroutines to define initial temperature for the dynamo benchmark Case 1 is shown below as an example.

After updating the source code, the program \verb|sph_initial_field| needs to be updated. To update the program, move to the work directory \verb|[CALYPSO_HOME]/work| and run make command as
% 
\begin{verbatim}
% cd \verb|[CALYPSO_HOME]/work|
% make
\end{verbatim}
%
Then, the program  \verb|sph_initial_field| and  \verb|sph_add_initial_field| are updated.

%
{\small
\begin{verbatim}
!
      subroutine set_initial_temperature
!
      use m_sph_spectr_data
!
      integer ( kind = kint) :: inod, k, jj
      real (kind = kreal) :: pi, rr, xr, shell
      real(kind = kreal), parameter :: A_temp = 0.1d0
!
!
!$omp parallel do
      do inod = 1, nnod_rj
        d_rj(inod,ipol%i_temp) = zero
      end do
!$omp end parallel do
!
      pi = four * atan(one)
      shell = r_CMB - r_ICB
!
!   search address for (l = m = 0)
      jj = find_local_sph_mode_address(0, 0)
!
!   set reference temperature if (l = m = 0) mode is there
      if (jj .gt. 0) then
        do k = 1, nlayer_ICB-1
          inod = local_sph_data_address(k,jj)
          d_rj(inod,ipol%i_temp) = 1.0d0
        end do
        do k = nlayer_ICB, nlayer_CMB
          inod = local_sph_data_address(k,jj)
          d_rj(inod,ipol%i_temp) = (ar_1d_rj(k,1) * 20.d0/13.0d0        &
     &                              - 1.0d0 ) * 7.0d0 / 13.0d0
        end do
      end if
!
!
!    Find local addrtess for (l,m) = (4,4)
      jj =  find_local_sph_mode_address(4, 4)
!      jj =  find_local_sph_mode_address(5, 5)
!
!    If data for (l,m) = (4,4) is there, set initial temperature
      if (jj .gt. 0) then
!    Set initial field from ICB to CMB
        do k = nlayer_ICB, nlayer_CMB
!
!    Set radius data
          rr = radius_1d_rj_r(k)
!    Set 1d address to substitute at (Nr, j)
          inod = local_sph_data_address(k,jj)
!
!    set initial temperature
          xr = two * rr - one * (r_CMB+r_ICB) / shell
          d_rj(inod,ipol%i_temp) = (one-three*xr**2+three*xr**4-xr**6)  &
     &                            * A_temp * three / (sqrt(two*pi))
        end do
      end if
!
!    Center
      if(inod_rj_center .gt. 0) then
        jj = find_local_sph_mode_address(0, 0)
        inod = local_sph_data_address(1,jj)
        d_rj(inod_rj_center,ipol%i_temp) = d_rj(inod,ipol%i_temp)
      end if
!
      end subroutine set_initial_temperature
!
\end{verbatim}
}
%

\subsection{Initial field modification program \\
({\tt sph\_add\_initial\_field})}
\label{sec:add_initial_field}
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{Images/flow_ini}
\end{center}
\caption{Data flow for initial field modification program.}
\label{fig:flow_add_ini}
\end{figure}
%
{\bf Caution: This program overwrites existing initial field data. Please run it after taking a backup.} \\

 This program modifies or adds new data to an initial field file. It could be used to start a new geodynamo simulation by adding seed magnetic field or source terms to a non-magnetic convection simulation. The initial fields to be added are also defined in \verb|const_sph_initial_spectr.f90|. \verb|data_utilities/INITIAL_FIELD/| directory. This program also needs the files listed in Table \ref{table:add_inital_fld}.
%
\begin{table}[htp]
\caption{List of files for simulation {\tt sph\_add\_initial\_field} }
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
 name & Parallelization & I/O \\ \hline \hline
\verb|control_MHD| & Serial & Input \\ \hline
\verb|[sph_prefix].[rj_extension]|  & - & Input / (Output) \\
\verb|[sph_prefix].[rlm_extension]| & - & Input / (Output)  \\
\verb|[sph_prefix].[rtm_extension]| & - & Input / (Output)  \\
\verb|[sph_prefix].[rtp_extension]| & - & Input / (Output)  \\ \hline
\verb|[rst_prefix].[step #].[rst_extension]| & - & Input/Output  \\ \hline
\end{tabular}
\end{center}
(Output): Marked files are generated if files do not exist.
\label{table:add_inital_fld}
\end{table}
%
This program generates the spectrum data files \verb|[rst_prefix].[step#].[rst_extension]|. To use generated initial data file, set 
 \hyperref[href_t:i_step_init_ctl]{{\tt [ISTEP\_START]}} and \verb|[ISTEP_RESTART]| to be appropriate time step and increment, respectively.
To read the original initial field data, \hyperref[href_t:restart_file_ctl]{{\tt [INITIAL\_TYPE]}} is set to be \hyperref[href_t:restart_file_ctl]{{\tt start\_from\_rst\_file}} in \verb|control_MHD|. In other words, the \verb|[step #]| in the file name, \hyperref[href_t:i_step_init_ctl]{{\tt [ISTEP\_START]}}, and \verb|[ISTEP_RESTART]| in the control file should be the consistent.

This program also uses the module file \verb|const_sph_initial_spectr.f90| to define the initial field. The initial fields are defined as following the previous section \ref{sec:def_initial}. After updating the source code, the program \verb|sph_initial_field| needs to be updated. After modifying  \verb|const_sph_initial_spectr.f90|, the program is build by make command in  the work directory \verb|[CALYPSO_HOME]/work|.

\subsection{Sectioning program ({\tt sectioning})} \label{sec:sectioning}
This program generates cross sections and isosurfaces from FEM mesh data and field data using the sectioning and isosurface module in the simulation program {\tt sph\_mhd}. The data for this program is listed in Table \ref{table:sectioning}. This program run on the parallel environment, and needs to use the same number of MPI processes as the number of processes which is used for the simulation program. VTK and compressed VTK data is not supported for the input field data.
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{Images/flow_5}
\end{center}
\caption{Data flow for sectioning program.}
\label{fig:flow_add_ini}
\end{figure}
%
\begin{table}[htp]
\caption{List of files for sectioning {\tt sectioning} }
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
name & Parallelization & I/O \\ \hline \hline
\verb|control_viz| & Serial & Input \\ \hline
\verb|[mesh_prefix].[fem_extension]| & - & Input \\ \hline
\verb|[fld_prefix].[step#].[domain#].[extension]| & - & Input  \\ \hline
\verb|[section_prefix].[step#].[extension]| &  Single & Output  \\
\verb|[isosurface_prefix].[step#].[extension]| &  Single & Output  \\ \hline
\end{tabular}
\end{center}
\label{table:sectioning}
\end{table}
%

\subsubsection{Control file}
The format of the control file \verb|control_viz| is described below. The detail of each block is described in section \ref{section:def_control}. You can jump to detailed description by clicking each item". \\
\\
%
Block \verb|visualizer|  (Top block of the control file)
\label{href_i:visualizer}
%
\begin{itemize}
\item Block \hyperref[href_t:data_files_def]{\tt data\_files\_def}
	\label{href_i:data_files_def_v}
%
	\begin{itemize}
	\item \hyperref[href_t:num_subdomain_ctl]
			{\tt num\_subdomain\_ctl    [Num\_PE]}
	\item \hyperref[href_t:num_smp_ctl]
			{\tt num\_smp\_ctl    [Num\_Threads]}
	\item \hyperref[href_t:mesh_file_prefix]
			{\tt mesh\_file\_prefix    [mesh\_prefix]}
	\item \hyperref[href_t:field_file_prefix]
			{\tt field\_file\_prefix    [fld\_prefix]}
%
	\item \hyperref[href_t:mesh_file_fmt_ctl]
			{\tt mesh\_file\_fmt\_ctl    [mesh\_format]}
	\item \hyperref[href_t:field_file_fmt_ctl]
			{\tt field\_file\_fmt\_ctl    [fld\_format]}
	\end{itemize}
%
\item Block \hyperref[href_t:time_step_ctl]{\tt time\_step\_ctl}
	\begin{itemize} \label{href_i:time_step_ctl_v}
	\item \hyperref[href_t:i_step_init_ctl]
		{\tt i\_step\_init\_ctl        [ISTEP\_START]}
	\item \hyperref[href_t:i_step_finish_ctl]
		{\tt i\_step\_finish\_ctl      [ISTEP\_FINISH]}
	\item \hyperref[href_t:i_step_field_ctl]
		{\tt i\_step\_field\_ctl       [ISTEP\_FIELD]}
	\item \hyperref[href_t:i_step_sectioning_ctl]
		{\tt i\_step\_sectioning\_ctl  [ISTEP\_SECTION]}
	\item \hyperref[href_t:i_step_isosurface_ctl]
		{\tt i\_step\_isosurface\_ctl  [ISTEP\_ISOSURFACE]}
	\end{itemize}
%
\item Block \hyperref[href_t:visual_control]{\tt visual\_control}
    \begin{itemize} \label{href_i:visual_control_v}
    \item \hyperref[href_t:i_step_sectioning_ctl]
        {\tt i\_step\_sectioning\_ctl  [ISTEP\_SECTION]}
    \item Array \hyperref[href_t:cross_section_ctl]{\tt cross\_section\_ctl}
		\begin{itemize}
        \item File or Block {\tt cross\_section\_ctl} \\
                            {\tt [section\_control\_file]} \\
								(See section \ref{section:section_control})
		\end{itemize}
%
    \item \hyperref[href_t:i_step_isosurface_ctl]
		{\tt i\_step\_isosurface\_ctl  [ISTEP\_ISOSURFACE]}
    \item Array \hyperref[href_t:isosurface_ctl]{\tt isosurface\_ctl}
		\begin{itemize}
		\item File or Block {\tt isosurface\_ctl} \\
                            {\tt [isosurface\_control\_file]} \\
								(See section \ref{section:isosurface_control})
		\end{itemize}
    \end{itemize}
\end{itemize}
%

\subsection{Field data converter program ({\tt field\_to\_VTK})}
\label{sec:field_to_VTK}
This program generates VTK data from FEM mesh data and field data. The data for this program is listed in Table \ref{table:fld_to_vtk}. This program run on the parallel environment, and needs to use the same number of MPI processes as the number of processes which is used for the simulation program.
%
\begin{table}[htp]
\caption{List of files for sectioning {\tt sectioning} }
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
name & Parallelization & I/O \\ \hline \hline
\verb|control_viz| & Serial & Input \\ \hline
\verb|[mesh_prefix].[fem_extension]| & - & Input \\ \hline
\verb|[fld_prefix].[step#].[domain#].[extension]| & - & Input  \\ \hline
\verb|[fld_prefix].[step#].[domain#].[vtk]| or [vtk.gz] & - & Output  \\ \hline
\end{tabular}
\end{center}
\label{table:sectioning}
\end{table}
%

\newpage
\subsubsection{Control file}
The format of the control file \verb|control_viz| is described below. The detail of each block is described in section \ref{section:def_control}. You can jump to detailed description by clicking each item". \\
\\
%
Block \verb|visualizer|  (Top block of the control file)
\label{href_i:visualizer}
%
\begin{itemize}
\item Block \hyperref[href_t:data_files_def]{\tt data\_files\_def}
	\label{href_i:data_files_def_f}
%
	\begin{itemize}
	\item \hyperref[href_t:num_subdomain_ctl]
			{\tt num\_subdomain\_ctl    [Num\_PE]}
	\item \hyperref[href_t:num_smp_ctl]
			{\tt num\_smp\_ctl    [Num\_Threads]}
	\item \hyperref[href_t:mesh_file_prefix]
			{\tt mesh\_file\_prefix    [mesh\_prefix]}
	\item \hyperref[href_t:field_file_prefix]
			{\tt field\_file\_prefix    [fld\_prefix]}
%
	\item \hyperref[href_t:mesh_file_fmt_ctl]
			{\tt mesh\_file\_fmt\_ctl    [mesh\_format]}
	\item \hyperref[href_t:field_file_fmt_ctl]
			{\tt field\_file\_fmt\_ctl    [fld\_format]}
	\end{itemize}
%
\item Block \hyperref[href_t:time_step_ctl]{\tt time\_step\_ctl}
	\begin{itemize} \label{href_i:time_step_ctl_f}
	\item \hyperref[href_t:i_step_init_ctl]
		{\tt i\_step\_init\_ctl        [ISTEP\_START]}
	\item \hyperref[href_t:i_step_finish_ctl]
		{\tt i\_step\_finish\_ctl      [ISTEP\_FINISH]}
	\item \hyperref[href_t:i_step_field_ctl]
		{\tt i\_step\_field\_ctl       [ISTEP\_FIELD]}
	\end{itemize}
%
\item Block \hyperref[href_t:visual_control]{\tt visual\_control}
    \begin{itemize} \label{href_i:visual_control_v}
    \item \hyperref[href_t:output_field_file_fmt_ctl]
		{\tt output\_field\_file\_fmt\_ctl  [VTK\_format]}
    \end{itemize}
\end{itemize}
%

\subsection{Section and isosurface data converter program ({\tt section\_to\_VTK})} 
\label{section:section_to_VTK}
This program generates VTK data from bindary sectioning and isosurface data. This program run on a single processor, and needs interactive input. The following is the console output of the program.

{\small
\begin{verbatim}
% /usr/local/Calypso/bin/section_to_VTK
Input file prefix
zm_y0									<- Input file prefix
Input file extension from following:
vtk, vtk.gz, vtd, vtd.gz, inp, inp.gz, udt, udt.gz, psf, psf.gz, sdt, sdt.gz  
sdt.gz									<- Input extension
ifmt_input          23
Input start, end, and increment of file step
{\color{red} 2004 2000 1								<- Input start, end, and increment of file step} 
Write ascii VTK file: zm_y0.2000.vtk
\end{verbatim}
}

\subsection{Restart data assemble program ({\tt assemble\_sph})}
\label{section:assemble_sph}
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{Images/flow_4}
\end{center}
\caption{Data flow for spectrum data assemble program}
\label{fig:flow_4}
\end{figure}
%
Calypso uses distributed data files for simulations. This program is to generate new spectrum data for restarting with different spatial resolution or parallel configuration. This program organizes new spectral data by using specter indexing data using different domain decomposition. The following files used for data IO. If radial resolution is changed from the original data, the program makes new spectrum data by linear interpolation. If new data have smaller or larger truncation degree, the program fills zero to the new spectrum data or truncates the data to fit the new spatial resolution, respectively. This program can perform with any number of MPI processes, but we recommend to run the program with {\bf one} process or the same number of processes as the number of subdomains for the target configuration which is defined by \verb|num_new_domain_ctl|. Data files for the program are shown In Table \ref{table:assemble_newsph}. The time and number of time step can also be changed by this program. The new time and time step are defined by the parameters in \verb|new_time_step_ctl| block. The step number of the restart data will be \verb|i_step_init_ctl| / \verb|i_step_rst_ctl| in  \verb|new_time_step_ctl|. If \verb|new_time_step_ctl| block is not defined, time and time step informations are carried from the original restart data.

%
\begin{table}[htp]
\caption{List of files for {\tt assemble\_sph} }
\begin{center} 
\begin{tabular}{|c|c|c|}
\hline
 extension & Distributed? & I/O \\ \hline
\verb|control_assemble_sph| & Serial & Input \\ \hline
\verb|[sph_prefix].[rj_extension]|  & - & Input \\  \hline
\verb|[new_sph_prefix].[domain#].rj| &  Distributed & Input \\ \hline
\verb|[rst_prefix].[step#].[rst_extension]| & - & Input  \\
\verb|[new_rst_prefix].[step#].[domain#].fst| &  Distributed & Output \\ \hline
\end{tabular}
\end{center}
\label{table:assemble_newsph}
\end{table}
%

\subsubsection{Format of control file}
Control file consists the following groups. \\
%
Block \verb|assemble_control| \label{href_i:assemble_control} (Top lebel of the block)
\begin{itemize}
\item Block \verb|data_files_def|
	\hyperref[href_t:data_files_def]{(Detail)}
	\begin{itemize}
	\item \hyperref[href_t:num_subdomain_ctl]
			{\tt num\_subdomain\_ctl    [Num\_PE]}
	\item \hyperref[href_t:sph_file_prefix]
			{\tt sph\_file\_prefix      [sph\_prefix]}
	\item \hyperref[href_t:restart_file_prefix]
            {\tt restart\_file\_prefix  [rst\_prefix])}
%
	\item \hyperref[href_t:sph_file_fmt_ctl]
			{\tt sph\_file\_fmt\_ctl    [sph\_format]}
	\item \hyperref[href_t:restart_file_fmt_ctl]
			{\tt restart\_file\_fmt\_ctl    [rst\_format]}
	\end{itemize}
%
\item Block \verb|new_data_files_def|
	\label{href_i:new_data_files_def}
	\hyperref[href_t:new_data_files_def]{(Detail)}
	\begin{itemize}
	\item \hyperref[href_t:num_subdomain_ctl]
			{\tt num\_subdomain\_ctl    [Num\_PE]}
	\item \hyperref[href_t:sph_file_prefix]
			{\tt sph\_file\_prefix      [sph\_prefix]}
	\item \hyperref[href_t:restart_file_prefix]
            {\tt restart\_file\_prefix  [rst\_prefix])}
%
	\item \hyperref[href_t:sph_file_fmt_ctl]
			{\tt sph\_file\_fmt\_ctl    [sph\_format]}
	\item \hyperref[href_t:restart_file_fmt_ctl]
			{\tt restart\_file\_fmt\_ctl    [rst\_format]}
%
	\item \hyperref[href_t:delete_original_data_flag]
			{\tt delete\_original\_data\_flag    [YES or NO]}
	\end{itemize}
%
\item Block \verb|control|
	\begin{itemize}
	\item Block \hyperref[href_t:time_step_ctl]{\tt time\_step\_ctl}
		\begin{itemize} \label{href_i:time_step_ctl2}
		\item \hyperref[href_t:i_step_init_ctl]
			{\tt i\_step\_init\_ctl        [ISTEP\_START]}
		\item \hyperref[href_t:i_step_finish_ctl]
			{\tt i\_step\_finish\_ctl      [ISTEP\_FINISH]}
		\item \hyperref[href_t:i_step_rst_ctl]
			{\tt i\_step\_rst\_ctl         [ISTEP\_RESTART]}
		\end{itemize}
%
	\item  Block \hyperref[href_t:i_step_init_ctl]{\tt new\_time\_step\_ctl}
		\begin{itemize} \label{href_i:new_time_step_ctl}
		\item \hyperref[href_t:i_step_init_ctl_a]
			{\tt i\_step\_init\_ctl        [ISTEP\_START]}
		\item \hyperref[href_t:i_step_rst_ctl_a]
			{\tt i\_step\_rst\_ctl         [ISTEP\_RESTART]}
		\item \hyperref[href_t:time_init_ctl_a]
			{\tt time\_init\_ctl           [INITIAL\_TIME]}
		\end{itemize}
	\end{itemize}
%
\item Block \hyperref[href_t:newrst_magne_ctl]{\tt newrst\_magne\_ctl}
	\begin{itemize} \label{href_i:newrst_magne_ctl}
	\item \hyperref[href_t:magnetic_field_ratio_ctl]
		{\tt magnetic\_field\_ratio\_ctl    [ratio]}
	\end{itemize}
\end{itemize}

\subsection{Time averaging program  ({\tt t\_ave\_monitor\_data})}
\label{sec:ave_mean_square}
This program generate time average and standard deviation of monitoring data defined in {\tt sph\_monitor\_ctl} block. This program read a control file {\tt control\_sph\_time\_average}. the control parameters are the following:
%
Block \verb|time_averaging_sph_monitor|  (Top block of the control file)
\label{href_i:time_averaging_sph_monitor}
%
\begin{itemize}
\item \hyperref[href_t:tave_start_time_ctl]
		{\tt start\_time\_ctl    [TIME]}
\item \hyperref[href_t:tave_end_time_ctl]
		{\tt end\_time\_ctl      [TIME]}
\item Block {\tt monitor\_data\_list\_ctl}
				\label{href_i:data_files_def}
	\begin{itemize}
	\item array \hyperref[href_t:volume_integrate_prefix]
				{\tt volume\_integrate\_prefix    [File\_Prefix]}
				\label{href_i:volume_integrate_prefix}
	\item array \hyperref[href_t:volume_sph_spectr_prefix]
				{\tt volume\_sph\_spectr\_prefix   [File\_Prefix]}
				\label{href_i:volume_sph_spectr_prefix}
	\item array \hyperref[href_t:sphere_integrate_prefix]
				{\tt sphere\_integrate\_prefix     [File\_Prefix]}
				\label{href_i:sphere_integrate_prefix}
	\item array \hyperref[href_t:layer_sph_spectr_prefix]
				{\tt layer\_sph\_spectr\_prefix    [File\_Prefix]}
				\label{href_i:layer_sph_spectr_prefix}
	\item array \hyperref[href_t:picked_sph_prefix]
				{\tt picked\_sph\_prefix           [File\_Prefix]}
				\label{href_i:picked_sph_prefix}
	\end{itemize}
%
\end{itemize}
%
There are five types of the monitor data to be averaged. The corresponding monitor data prefixes for each type are listed in Tables \ref{table:volume_integrate_prefix} to \ref{table:picked_sph_prefix}. If data is end before the end time, the program will finish at the end of file. \verb|t_ave| and \verb|t_sigma| are added at the beginning of the input file name for the time average and standard deviation data file, respectively.

%
\begin{table}[htp]
\caption{List of avaiable monitor data for {\tt [volume\_integrate\_prefix]}}
\begin{center} 
\begin{tabular}{|c|}
\hline
 name  \\ \hline \hline
\verb|[vol_pwr_prefix]_s|   \\
\verb|[vol_pwr_prefix]_m0|   \\
\verb|[vol_ave_prefix]|   \\
\verb|[gauss_coef_prefix]|     \\
\verb|[nusselt_number_prefix]|     \\
\verb|[dipolarity_file_prefix]|     \\
\verb|[dynamo_benchmark_data_ctl]|     \\ \hline
\end{tabular}
\end{center}
\label{table:volume_integrate_prefix}
\end{table}
%
\begin{table}[htp]
\caption{List of avaiable monitor data for {\tt [volume\_sph\_spectr\_prefix]}}
\begin{center} 
\begin{tabular}{|c|}
\hline
 name  \\ \hline \hline
\verb|[vol_pwr_prefix]_l|   \\
\verb|[vol_pwr_prefix]_m|   \\
\verb|[vol_pwr_prefix]_lm|    \\ \hline
\end{tabular}
\end{center}
\label{table:volume_sph_spectr_prefix}
\end{table}
%
\begin{table}[htp]
\caption{List of avaiable monitor data for {\tt [sphere\_integrate\_prefix]}}
\begin{center} 
\begin{tabular}{|c|}
\hline
 name  \\ \hline \hline
\verb|[layer_pwr_prefix]_s|   \\
\verb|[layer_pwr_prefix]_m0|   \\
\verb|[field_on_circle_prefix]|     \\ \hline
\end{tabular}
\end{center}
\label{table:sphere_integrate_prefix}
\end{table}
%
\begin{table}[htp]
\caption{List of avaiable monitor data for {\tt [layer\_sph\_spectr\_prefix]}}
\begin{center} 
\begin{tabular}{|c|}
\hline
 name  \\ \hline \hline
\verb|[layer_pwr_prefix]_l|   \\
\verb|[layer_pwr_prefix]_m|   \\
\verb|[layer_pwr_prefix]_lm|   \\
\verb|[spectr_on_circle_prefix]|     \\ \hline
\end{tabular}
\end{center}
\label{table:layer_sph_spectr_prefix}
\end{table}
%
%
\begin{table}[htp]
\caption{List of avaiable monitor data for {\tt [picked\_sph\_prefix]}}
\begin{center} 
\begin{tabular}{|c|}
\hline
 name  \\ \hline \hline
\verb|[picked_sph_prefix]| \\ \hline
\end{tabular}
\end{center}
\label{table:picked_sph_prefix}
\end{table}
%

\subsection{Module dependency program ({\tt make\_f90depends})}
\label{sec:make_f90depends}
This program is only used to generate Makefile in {\tt work} directory. Most of case, Fortran 90 modules have to compiled prior to be referred by another fortran90 routines. This program is generates dependency lists in Makefile. To use this program, the following limitation is required.
\begin{itemize}
\item One source code has to consist of one module.
\item The module name should be the same as the file name.
\end{itemize}
%

\subsection{Visualization using field data}
\label{sec:paraview}
The field data is written by XDMF or VTK data format using Cartesian coordinate. In this section we briefly introduce how to display the radial magnetic field using ParaView as an example.
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{Images/paraview_open}
\caption{File open window for ParaView}
\label{fig:paraview_load}
\end{center}
\end{figure}
%

After the starting Paraview, the file to be read is chosen in the file menu, and press "apply", button. Then, Paraview load the data from files (see Figure \ref{fig:paraview_load}). 
Because the magnetic field is saved by the Cartesian coordinate, the radial magnetic field is obtained by the calculator tool. The procedure is as following (see Figure \ref{fig:paraview_gen_Br})
%
\begin{enumerate}
\item Push calculator button.
\item Choose "Point Data" in Attribute menu
\item Input data name for radial magnetic field ("B\_r" in  Figure \ref{fig:paraview_gen_Br})
\item Enter the equation to evaluate radial mantic field $B_{r} = \bvec{B} \cdot \bvec{r} / |r|$.
\item Finally, push "Apply" button.
\end{enumerate}
%
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=100mm]{Images/paraview_calc}
\caption{File open window for ParaView}
\label{fig:paraview_gen_Br}
\end{center}
\end{figure}
%
After obtaining the radial mantric field, the image in figure \ref{fig:paraview_br} is obtained by using "slice" and  "Contour" tools with appropriate color mapping.
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=100mm]{Images/Paraview_Br}
\end{center}
\caption{Visualization of radial magnetic field by Paraview.}
\label{fig:paraview_br}
\end{figure}
%

\newpage
\section{Deprecated features}
There are some deprecated features and programs from the Calypso Ver. 1.x. These programs are still helpful for development, debug, and to convert dat from Ver.1.x.

\subsection{Preprocessing program ({\tt gen\_sph\_grid})}
\label{section:gen_sph_grid}
%
From Ver. 2, the spherical harmonic indices data is not necessary if the parameters for the spherical shell described below is included in the control for the simulation. However, This program \verb|gen_sph_grid| is still useful for debug and I will describe how to set up the parallelization in this subsection.
%
\begin{figure}[htbp]
\begin{center}
\includegraphics*[width=130mm]{Images/flow_1}
\end{center}
\caption{Generated files by preprocessing program in Data flow.}
\label{fig:gen_sph_grid}
\end{figure}
%
This program generates index table and a communication table for parallel spherical harmonics, table of integrals for Coriolis term, and FEM mesh information to generate visualization data (see Figure \ref{fig:gen_sph_grid}). This program needs control file for input. This program can perform with {\bf any} number of MPI processes less than the number of subdomains, but is required to run with the SAME number of subdomains to generate MERGED data . The output files include the indexing tables. 

%
\begin{table}[htp]
\caption{List of files for {\tt gen\_sph\_grid} }
\begin{center} 
\begin{tabular}{|c|c|c|c|}
\hline
Files & extension & Parallelization & I/O \\ \hline \hline
Control file & \verb|control_sph_grid| & Single & Input \\ \hline
Index for $(r,j)$ & \verb|[sph_prefix].[rj_extension]| & - & Output \\
Index for $(r,l,m)$ & \verb|[sph_prefix].[rlm_extension]| & - & Output \\
Index for $(r,t,m)$ & \verb|[sph_prefix].[rtm_extension]| & - & Output \\
Index for $(r,t,p)$ & \verb|[sph_prefix].[rtp_extension]| & - & Output \\ \hline
FEM mesh & \verb|[sph_prefix].[fem_extension]| & - & Output \\ \hline
Radial point list & \verb|radial_info.dat| & Single & Output \\ \hline
\end{tabular}
\end{center}
\label{table:gen_sph_grid}
\end{table}
%
%
\begin{table}[htp]
\caption{data format flag {[\tt sph\_file\_fmt\_ctl]} and extensions.}
\begin{center} 
\begin{tabular}{|c||c|c|c|c|}
\hline
  \multicolumn{5}{|c|}{Distributed files} \\ \hline
  \verb|[sph_file_fmt_ctl]| &  \verb|ascii| & \verb|binary| & \verb|gzip| & \verb|bin_gz| \\ \hline
\verb|[rj_extension]|  & \verb|[#].rj|  & \verb|[#].brj| & \verb|[#].rj.gz|  & \verb|[#].brj.gz| \\
\verb|[rlm_extension]| & \verb|[#].rlm| & \verb|[#].blm| & \verb|[#].rlm.gz| & \verb|[#].blm.gz| \\
\verb|[rtm_extension]| & \verb|[#].rtm| & \verb|[#].btm| & \verb|[#].rtm.gz| & \verb|[#].btm.gz| \\
\verb|[rtp_extension]| & \verb|[#].rtp| & \verb|[#].btp| & \verb|[#].rtp.gz| & \verb|[#].btp.gz| \\ \hline
\verb|[fem_extension]| & \verb|[#].gfm| & \verb|[#].gfb| & \verb|[#].gfm.gz| & \verb|[#].gfb.gz| \\ \hline \hline
  \multicolumn{5}{|c|}{Single file}  \\ \hline
  \verb|[sph_file_fmt_ctl]| & \verb|merged| & \verb|merged_bin| & \verb|merged_gz| & \verb|merged_bin_gz| \\ \hline
\verb|[rj_extension]|   & \verb|.rj|  & \verb|.brj| & \verb|.rj.gz|  & \verb|.brj.gz| \\
\verb|[rlm_extension]| & \verb|.rlm| & \verb|.blm| & \verb|.rlm.gz| & \verb|.blm.gz| \\
\verb|[rtm_extension]| & \verb|.rtm| & \verb|.btm| & \verb|.rtm.gz| & \verb|.btm.gz| \\
\verb|[rtp_extension]| & \verb|.rtp| & \verb|.btp| & \verb|.rtp.gz| & \verb|.btp.gz| \\ \hline
\verb|[fem_extension]| & \verb|.gfm| & \verb|.gfb| & \verb|.gfm.gz| & \verb|.gfb.gz| \\ \hline \hline
  \multicolumn{5}{c}{{\tt [\#]} is the domain or process number} \\
\end{tabular}
\end{center}
\label{table:mesh_format}
\end{table}
%
\subsubsection{Control file (\tt{control\_sph\_shell})}
\label{section:control_sph_shell}
Control file ({\tt control\_sph\_shell}) consists the following items. Detailed description for each item can be checked by clicking each item.
\\
%
\verb|spherical_shell_ctl|
\label{href_i:spherical_shell_ctl}
\\
\\
%
Block {\tt MHD\_control} (Top block of the control file)
	\begin{itemize}
	\item Block \hyperref[href_t:data_files_def]{\tt data\_files\_def}
	\item File \hyperref[href_t:spherical_shell_ctl]{\tt spherical\_shell\_ctl    [resolution\_control]}
	\item or Block \hyperref[href_t:spherical_shell_ctl]{\tt spherical\_shell\_ctl}
	\end{itemize}

If \verb|num_radial_domain_ctl| and \verb|num_horizontal_domain_ctl| are defined, the following arrays \verb|num_domain_sph_grid|, \verb|num_domain_legendre|, and \verb|num_domain_spectr| are not necessary. \\
(see \hyperref[href_t:gen_w_innercore]{example} \verb|spherical_shell/with_inner_core|)
%
\subsubsection{Spectrum index data}
\verb|gen_sph_grid| generates indexing table of the spherical transform. To perform spherical harmonics transform with distributed memory computers, data communication table is also included in these files. Calypso needs four indexing data for the spherical transform.
%
\begin{description}
\item{\verb|[sph_prefix].[rj_extension]|} Indexing table for spectrum data $f(r,l,m)$ to calculate linear terms. In program,  spherical harmonics modes $(l,m)$ is indexed by $j = l(l+1) + m$. The spectrum data are decomposed by spherical harmonics modes $j$. Data communication table for Legendre transform is included. The data also have the radial index of the ICB and CMB. Extension \verb|[rj_extension]| is listed in Table \ref{table:mesh_format}.
\item{\verb|[sph_prefix].[rlm_extension]|} Indexing table for spectrum data $f(r,l,m)$ for Legendre transform. The spectrum data are decomposed by radial direction $r$ and spherical harmonics order $m$. Data communication table to caricurate liner terms is included. Extension \verb|[rlm_extension]| is listed in Table \ref{table:mesh_format}.
\item{\verb|[sph_prefix].[rtm_extension]|} Indexing table for data $f(r,\theta,m)$ for Legendre transform. The data are decomposed by radial direction $r$ and spherical harmonics order $m$. Data communication table for backward Fourier transform is included. Extension \verb|[rtm_extension]| is listed in Table \ref{table:mesh_format}.
\item{\verb|[sph_prefix].[rtp_extension]|} Indexing table for data $f(r,\theta,m)$ for Fourier transform and field data $f(r,\theta,\phi)$. The data are decomposed by radial direction $r$ and meridional direction $\theta$. Data communication table for forward Legendre transform is included. Extension \verb|[rtp_extension]| is listed in Table \ref{table:mesh_format}.
\end{description}
%

\subsubsection{Finite element mesh data (optional)}
Calypso generates field data for visualization with XDMF or VTK format. To generate field data file, the preprocessing program generates FEM mesh data for each subdomain of spherical grid $(r,\theta,\phi)$ under the Cartesian coordinate $(x,y,z)$. The mesh data file is written based on GeoFEM (\url{http://geofem.tokyo.rist.or.jp}) mesh data format, which consists of each subdomain mesh and communication table among overlapped nodes. The extension of the mesh file is listed in Table \ref{table:mesh_format}. This mesh data is only used in the programs \hyperref[sec:sectioning]{\tt sectioning} and \verb|field_to_VTK|.

